NB. Define a web server/client DSL:
NB. use an emmet-like language for writing html-expressions, and tailwind for css, and J for JS
NB. examples and results written below

em '.foo#bar>ul>2*li' NB. create html based on expression
<div id="bar" class="foo">
	<ul>
 	<li></li>
 	<li></li>
 </ul>
</div>

NB. apply boxes on the right side (consistent with J and allows right-parened expressions)
(;: 'Hi didi') ap 'ul>*li{$}' NB. apply boxed array, looping on the starred subtree (not subexpression)
(;: 'Hi didi') ap 'ul>*li$'   NB. simplified syntax
<ul>
	<li>Hi</li>
	<li>didi</li>
</ul> 

(;: 'h1 p1 h2 p2') ap '*.page>h2$+p$' 
<div class="page">
	<h2>h1</h2>
	<p>p1</p>
</div>
<div class="page">
	<h2>h2</h2>
	<p>p2</p>
</div>

NB. get value from J
em 'h1{Hello $name}' ] name =: 'Hassan Shabbir'
<h1>Hello Hassan Shabbir</h1>

em 'h1{Hello $(|.name)}' ] name =: 'Hassan Shabbir' NB. J expressions in $()
<h1>Hello ribbahS nassaH</h1>

em 'img[src=www.google.com alt="an image"]' NB. attributes in [], space separated
<img src="www.google.com" alt="an image">

em 'p[style=$paraStyle]{hi}' NB. with paraStyle =: cut 'color purple font-family comic-sans,cursive font-size 2em'
<p style="color: purple; font-family: "Comic Sans", cursive; font-size: 2em;">hi</p>

em 'h1{hi}+$para' NB. para =: p{this is a paragraph} NB. components using variables in html positions
<h1>hi</h1>
<p>this is a paragraph</p>

em 'h1{hi}+3*$lorem' NB. lorem =: p{Lorem ipsum dolor sit amet} NB. lorem is a component
<h1>hi</h1>
<p>Lorem ipsum dolor sit amet</p>
<p>Lorem ipsum dolor sit amet</p>
<p>Lorem ipsum dolor sit amet</p>

em 'btn[clk=0:$v+1]{Clicked $v time$((v>1)?:'s')!}' NB. ?: is an if expression
<script>let v = 0;</script>
<button click="() => v = v+1">Clicked {v} time{v > 1 ? 's' : ''}!</button>

NB. $ extended to loop over boxed vectors; uses title case for props; as key-value pairs (also useful for styles)
em 'ul>*li{$obj}' ] obj =: ;: 'Name Hassan Age 23 Job Soft-dev City Pickering'
<ul>
  <li>Name: ${name}</li>
  <li>Age: ${age}</li>
  <li>Job: ${job}</li>
  <li>City: ${city}</li>
</ul>

em 'ul>li{$obj_name}' ] obj =: ;: 'Name Hassan Age 23 Job Soft-dev City Pickering' NB. get prop in object
<ul>
  <li>Name: ${name}</li>
  <li>Age: ${age}</li>
  <li>Job: ${job}</li>
  <li>City: ${city}</li>
</ul>

em 'btn[clk=$v+1]{$v doubled is $d}`v=0:+1;d=v*2`' NB. use `` for scripts; all vars that depend on referenced vars are auto updated
<script>let v = 0; let d = v * 2;</script>
<button click="() => v = v+1">{v} doubled is {d}</button>

NB. have a development and server version (ie dev =: 0 and dev =: 1)?

'/' serve em 'p{hello world}' NB. default port to 8080 and location to localhost (at least when dev =: 1)

'/didi' serve (;: 'Hi didi') ap 'ul>*li$' 

'/friends' serve (;: 'Aboo Mama Ahson Maria') ap 'h1{Your friends}+p{Here is a list of your friends:}+ul>*li$'

'/friend-details' serve (;: 'Aboo 60 Mama 57 Ahson 30 Maria 26') ap 'h1{Your friends}+p{Here is a list of your friends:}+ul>*li{$ ($ years old)}'

NB. differentiate between escaped and unescaped html code
NB. component support (place html,css,js in the correct spot in the DOM)
NB. automatic form generation and verification (including javascript verification) and parsing of put requests (into json object?)

NB. generate forms using the following expression
NB. seems like $_ at least will be needed to be able to reuse values more than once
(;: 'first-name last-name') ap 'form[action=/signup]>*(label[for=$]{$}+br+input#$[type=text name=$]+br)+input[type=submit value=Submit]'

t =: 4 3 $ ;: 'c1 c2 c3 b1 b2 b3 b4 b5 b6 b7 b8 b9'
NB. also add in sticky headers and zebra stripes
NB. num(tr) = rows - 1 (one is used for th); num(th) and num(td) = cols
em 'table>tr>th*3^tr*3>td*3'

NB. add in the ability to have nested components, like the following
em 'p{hi there my name is }+i{hassan}+p{how are you?}'
em 'p{hi there my name is i{hassan} how are you?}'

NB. default to placing the tags in the correct location (styles,title,meta in head, html in body, javascript at end of body)
NB. only include a library once (like JQuery)
NB. | splits between head (before |) and body (after |) and automatically move scripts to end of body if in the body
em 'title{my app}|script{console.log("hi")}+h1{this is my app}'

em 'title{title}+script[src=/included-in-head.js]|script[src=/included-in-body.js]'

NB. automatically add comments in generated html and css and uncompress code when in dev mode; add compression and minification and remove html/css comments

NB. components should be composable like the following:
a =: em 'h1[style="color:green;"]{My Title}' 
b =: em 'title{My page title}+script[src=http://www.example.com/script.js]' 
c =: em '$a+$b'

footer =: em 'footer[style="fwb tac"]>p{That is all folks!}'
page =: em 'p{my page.}+$footer'
NB. OR (without using components)
page =: em 'p{my page.}+footer[style="fwb tac"]>p{That is all folks!}'

section.blog[style='p1e b1s0 h1>c#ccf']

NB. define simplified notation that does not require the use of `[style='']` to define styles; for example:
section.blog%'p1e b1s0 h1>c#ccf'

NB. change ap to be reversed? (;: 'Hi didi') ap 'ul>*li{$}' => 'ul>*li{$}' ap ;: 'Hi didi'

NB. change serve function to get, post, put, delete functions

NB. @ is used as a suffix to refer to the sizes of screens, small, medium, large; in @[sml]{1,3}
p%'fs4em'@s%'fs3em'@m%'fs2em'@l
p%'fs3em'@sm

NB. define base url in a variable since it will be used to append to get, etc. as well as use in the base html tag

NB. remember to add this meta tag
meta[name=viewport content="width=device-width, initial-scale=1.0"]
meta[name=viewport content=width=device-width,initial-scale=1.0]

use the type system developed by Carol Tuttle to auto-design websites
for example, design =: 2 4, and have the css change based on that.
also give the ability to choose between the four components (different based on type) and the 
default chosen by the first type of design. ie:
$comp+$comp1+$comp2+$comp3+$comp4


NB. @ is used as a prefix to refer to the sizes of screens, small, medium, large; as in [sml]@
NB. this applies the rest of the styles to only those screen sizes
p%'s@fs4em'%'m@fs3em'%'l@fs2em'
p%'sm@fs3em'

NB. the design variable should be as follows: [1-4]([1-4][sm]){,2}
NB. where s stands for shape and m stands for movement
NB. eg. 2, 24m, 24s1m

NB. create a grid system with .g for creating 2-d grid, .r for creating a 1-d row
NB. with class .N referring to size out of 12 the element will take up
NB. .g is optional if only creating a row. .N is optional those elements will split
NB. the remaining space between themselves (1fr right?).

.r>img.3+p.9
<div class="r">
	<img class="3" src="" alt="">
	<p class="9"></p>
</div>

.g>.r>.a*3^.r>.a*3
<div class="g">
	<div class="r">
		<div class="a"></div>
		<div class="a"></div>
		<div class="a"></div>
	</div>
	<div class="r">
		<div class="a"></div>
		<div class="a"></div>
		<div class="a"></div>
	</div>
</div>

NB. create component functions such as the following:
NB. should components have multiple sections to interpolate into? (splats may be necessary)
NB. no, use nth value of tree if multiple values are needed
NB. use $$ for interpolation
NB. can looping and component definition be combined into one?
NB. use & to define component (auto-hidden subtree), and use $ to use it
'$footer{The fourth value comes from here}+&footer>.first>p{I}^.second>p{love}^.third>p{chocolate}^.fourth>p$$'
cta =: 'div>,' NB. or
cta =: 'div>,1+p{foo}+,2+,3'
$footer{.a}{.b}{.c} or as $footer{.a+.b+.c}
$cta{p{BUY, NOW!}+btn{BUY}} NB. call to action


NB. write about what influenced me
parenthesized expressions
(nav>.logo+.search+.button)+(.body>.page1+.page2+.page3)+(footer>.first+.second+.third)
eq without expression:

allow modifications within the language (toggle?)
.foo ~ #elem

think about how to combine javascript, J and a language to describe interactive functionality together

always dynamic values by default, then behaviour or event if needed

dynamically changing the value to be the number of clicks
references to elements become their event history in (reverse?) chronological order
name resolution order: id, class, html element, J var (therefore # and . can be continued to be used as J without disambiguation)
should a class name resolution combine all events from all selected elements, or those with a particular html element, or just the first element found with that class
button#b{Click me!}+p{You clicked the button `#b` times!} NB. count the number of events

last sent message
textarea#ta+button{Submit}+p{Your last sent message: `>{:>{:ta`.}

(dis)able button
checkbox#c{toggle}+submit[enabled=`>{:>{:c`]

Use _v (value) as a shortcut for >{:>{: and _e (event) for >{:
though other ones can be made such as first value _f* (1{) and previous value _p* ((n-1){)
textarea#ta+button{Submit}+p{Your last sent message: `ta_v`.}
ta+b{Submit}+p{Your last sent message: `ta_v`.}
checkbox#c{toggle}+submit[enabled=`c_v`]


Note that this does not work because a textarea should send an event on change
while the button submit only sends a click event, so then perhaps a form element
should contain sent events only when the submit button is pressed
form>ta+b{Submit}^p{Your last sent message: `ta_v`.}

dynamic attrs
gif =: 'rickAstley.gif'
img[src=gif]
OR should it be the following
img[src=`gif`]



svelte reactive assignments:
<script> let count = 0; function handleClick() { count += 1; } </script> <button on:click={handleClick}> Clicked {count} times </button>
my language example:
b{Clicked `#b` times}

svelte reactive declarations:
<script> let count = 1; $: doubled = count * 2; $: quadrupled = doubled * 2; function handleClick() { count += 1; } </script> <button on:click={handleClick}> Count: {count} </button> <p>{count} * 2 = {doubled}</p> <p>{doubled} * 2 = {quadrupled}</p>
my example:
b{Count: `#b`}+p{`#b` * 2 = `2*#b`}+p{`2*#b` * 2 = `4*#b`}


TODO: svelte reactive statements: (dont understand if expressions in J)
<script> let count = 0; $: if (count >= 10) { alert(`count is dangerously high!`); count = 9; } function handleClick() { count += 1; } </script> <button on:click={handleClick}> Clicked {count} times </button>


svelte looping over elements:
<script> let cats = [ { id: 'J---aiyznGQ', name: 'Keyboard Cat' }, { id: 'z_AbfPXTKms', name: 'Maru' }, { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' } ]; </script> 
<h1>The Famous Cats of YouTube</h1> <ul> {#each cats as { id, name }, i} <li><a target="_blank" href="https://www.youtube.com/watch?v={id}"> {i + 1}: {name} </a></li> {/each} </ul> 

my example: (use $# to refer to the ith loop)
'h1{The Famous Cats of YouTube}+ul>*li>a[href="https://www.youtube.com/watch?v=$$"]{$#: $$}' ap~ 'J---aiyznGQ';'Keyboard Cat';'z_AbfPXTKms';'Maru';'OUtn3pvWmpg';'Henri The Existential Cat'

negated
checkbox#c{toggle}+submit[enabled=`-.c_v`]


<script> let todos = [ { done: false, text: 'finish Svelte tutorial' }, { done: false, text: 'build an app' }, { done: false, text: 'world domination' } ]; </script> <h1>Todos</h1> {#each todos as todo} <div> <input type=checkbox bind:checked={todo.done} > <input bind:value={todo.text} disabled={todo.done} > </div> {/each}

note: change the data before passing it into the html portion if necessary
my example:
, 0 1 0 {"(1) 3 2 $ 0;'finish Svelte tutorial';0;'build an app';0;'world domination'
h1{Todos}+*div>checkbox[checked=$$]+textbox[value=$$ disabled=$$]


comparison with reflex-dom
{-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO() main = mainWidget $ do el "h1" $ text "Welcome to Reflex-Dom" el "div" $ do el "p" $ text "Reflex-Dom is:" el "ul" $ do el "li" $ text "Fun" el "li" $ text "Not difficult" el "li" $ text "Efficient"

h1{Welcome to Reflex-Dom}+div>p{Reflex-Dom is:}+ul>li{Fun}+li{Not difficult}+li{Efficient}

reflex-dom adding and subtracting using buttons:
{-# LANGUAGE RecursiveDo #-} {-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO () main = mainWidget bodyElement bodyElement :: MonadWidget t m => m () bodyElement = do rec counts <- foldDyn (+) (0 :: Int) $ leftmost [1 <$ evIncr, -1 <$ evDecr] el "div" $ display counts evIncr <- button "Increment" evDecr <- button "Decrement" return ()

b#a{Increment}+b#b{Decrement}+p{Total: `(#a)-#b`}

TODO reflex-dom combining event timelines:
{-# LANGUAGE RecursiveDo #-} {-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO () main = mainWidget bodyElement bodyElement :: MonadWidget t m => m () bodyElement = do el "h2" $ text "Using foldDyn with function application" rec dynNum <- foldDyn ($) (0 :: Int) $ leftmost [(+ 1) <$ evIncr, (+ (-1)) <$ evDecr, const 0 <$ evReset]  el "div" $ display dynNum evIncr <- button "Increment" evDecr <- button "Decrement" evReset <- button "Reset" return ()


to make the sorts (asc, desc) work, the first value in the event must be the timestamp of the occurrance
\:~ a,b,c

NB. use the dark reader firefox extesion to convert to a default dark mode value or vice versa

NB. apply styles using css selectors, as well as combinators (>^*~, etc)
p{hi} NB. creates p
p = .hi NB. sets all p to have hi class
p = {hi} NB. set all p body to hi, warn?
NB. therefore, p{hi} creates, p={hi} updates
NB. this is important otherwise data will be overwritten, eg.
.foo{Hi};.foo{Hello}

NB. what is the difference between ; (new command) and + (next sibling elem)
NB. should they be merged?

p = .bg-red-300 NB. sets all p to have red bg
p = .bg-red-300; #names = .bg-gray-200 NB. one-liner using ; evaluated left to right?
p = hi NB. error!
p = .bg-red-300 :hover.bg-red-600 NB. set multiple styles on one selector/element
#foo * = .red-300 NB. everything inside will have red text (recursive)

NB. use : to mean default interaction (click usually) and :hover for styles to apply on hover
#foo:hover.bg-red-300 NB. create foo id with red background only on hover
#foo:hover = .bg-red-300 NB. update foo to have this background on hover
#foo:hover.bg-red-300:focused.bg-red-400 NB. chain different effects
#foo:hover = .bg-red-300; #foo:focused = .bg-red-400

NB. determine a way of doing italics/bold/underline ie inline tags
p{foo b{bar} baz} => p{foo}+p.text-weight-800{bar}+p{baz} 
NB. should it use markdown styling?

NB. type system should be done with a special comment that defines the
following: 
1) general type (color, along with defaults of the rest), 
and only two (to determine the secondary) of the following:
2) design line (shapes)
3) texture
4) fabrication
5) pattern

NB. use @ to define styles rather than cluttering design with classes? 
NB. this can be said to be based on @apply I guess
NB. base the @command on the first letters of the two commands
NB. ie display:grid becomes @dg
NB. and padding-left:1rem; padding-right:1rem; becomes @px4
NB. create a scale that applies to all elements that does not have points

NB. use css reset, but only some parts (normalize.css)

NB. have an easy way of defining a grid (they should be very common)
NB. plus an easy way to define grid with elements centered

NB. all gen code should be responsive including things like typography

NB. set default styles in your file
h1 = .text-3xl.font-weight-800.text-gray-900

NB. check which ascii characters can be used
NB. create a language BNF

NB. how should elements be deleted, and how should dom traversal work

NB. how should components work?

NB. use scoped css (somewhat-)like in svelte: root styles affect everything,
NB. but component styling only affects the current component and not children

NB. also include the tag's properties as a map, ie. textarea_p
NB. for accessing the props such as colour?

value <- textArea; textBox $ fmap (++ "!") value
ta#i+p{`'!',~i_v`}

NB. React todo app
class TodoApp extends React.Component { constructor(props) { super(props); this.state = { items: [], text: '' }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } render() { return ( <div> <h3>TODO</h3> <TodoList items={this.state.items} /> <form onSubmit={this.handleSubmit}> <label htmlFor="new-todo"> What needs to be done?  </label> <input id="new-todo" onChange={this.handleChange} value={this.state.text} /> <button> Add #{this.state.items.length + 1} </button> </form> </div>); } handleChange(e) { this.setState({ text: e.target.value }); } handleSubmit(e) { e.preventDefault(); if (this.state.text.length === 0) { return; } const newItem = { text: this.state.text, id: Date.now() }; this.setState(state => ({ items: state.items.concat(newItem), text: '' })); } } class TodoList extends React.Component { render() { return ( <ul> {this.props.items.map(item => ( <li key={item.id}>{item.text}</li>))} </ul>); } } ReactDOM.render( <TodoApp />, document.getElementById('todos-example')); 
NB. svelte
<script> let newItem = ''; let todoList = [{text: 'Write my first post', status: true}, {text: 'Upload the post to the blog', status: false}, {text: 'Publish the post at Facebook', status: false}]; function addToList() { todoList = [...todoList, {text: newItem, status: false}]; newItem = ''; } function removeFromList(index) { todoList.splice(index, 1) todoList = todoList; } </script> <input bind:value={newItem} type="text" placeholder="new todo item.."> <button on:click={addToList}>Add</button> <br/> {#each todoList as item, index} <input bind:checked={item.status} type="checkbox"> <span class:checked={item.status}>{item.text}</span> <span on:click={() => removeFromList(index)}>‚ùå</span> <br/> {/each} <style> .checked { text-decoration: line-through; } </style> 

NB. my design for todo app
NB. var z is used to refer to current value of item
todoList = ul>li$+li{`z , form_v`}
NB. or perhaps it should be like this?: todoList = ul>li$form_v which would append the value to the end of the list items
]todoApp = div>h3{TODO}+todoList{`;: 'hello world'`}+form>label{What needs to be done?}+input+button{Add `>:#input`}:s
NB. dense version (10% the size of the react version)
div>h3{TODO}+(ul>li$form_v)+form>label{What needs to be done?}+input+button{Add #`>:#input`}:s

NB. reactive component attached to input field; form values submitted on submit
div>h3{TODO}+(ul>li$form_v)+p{Length of text entered: `#input`}+form>label{What needs to be done?}+input+button{Add #`>:#input`}:s

NB. * seems to be quite useless when defining expressions, perhaps it should be removed, eg: 
ul>li*3; li[0] = {foo}; li[1] = {bar}; li[2] = {baz}
NB. compared to
ul>li{foo}+li{bar}+li{baz}
NB. or using emmets implied tags
ul>{foo}+{bar}+{baz}

NB. what was the syntax for events again?
b:c{Click me!}
NB. or
b[clk]{Click me!}

NB. linked pages are pages that replace one subtree for another subtree when an event fires in the first subtree
NB. use & for linking?
NB. should the linking be like this?
foo = .page#d>h1{Hello World}+b#a{Click Here}
bar = .page#b>h1{Hello, World!}+b#c{Click Here again}
#a&#b;#c&#d
NB. or like this?
foo = .page>h1{Hello World}+b{Click Here}
bar = .page>h1{Hello, World!}+b{Click Here again}
foo&bar
NB. actually this can be replaced by the routes syntax, such as the following
NB. how should other aspects be dealt with such as :c or the get/foo expanded syntaxes?
NB. routes defined similar to component definition (but prefixed with /)
/foo = h1{Hello World}+b:/bar{Click Here} NB. on default event (click) route to /bar
/bar = h1{Hello, World!}+b:/foo{Click Here again}

NB. every element should be dynamic by default and only static when explicitly stated

NB. concat two values of input fields
NB. change a_v style values to instead be aV (saves one char typing and one visual character spot as well)
ta#a+ta#b+p`aV,bV`

NB. count the total of increments and decrements
NB. bacon.js
var minusOnes = $('#minusOne').asEventStream('click').map(-1); var plusOnes = $('#plusOne').asEventStream('click').map(1); var score = minusOnes.merge(plusOnes).scan(0, (sum, value) => sum + value); score.assign($('#score'), 'text')
NB. my way
b#a{-1}+b#b{+1}+p{Total: `(#b)-#a`} NB. shouldn't the interactivity (and its type [hover, click]) be noted on the b(utton)?; is it possible to remove giving things ids?

NB. add numbers
NB. bacon.js
function inputVal(ev) { return $(ev.currentTarget).val() }; function isNumber(n) { return n > 0 }; var a = $('#a').asEventStream('keyup').map(inputVal).map(parseInt).filter(isNumber).toProperty(0); var b = $('#b').asEventStream('keyup').map(inputVal).map(parseInt).filter(isNumber).toProperty(0); function sum(arg1, arg2) { return arg1 + arg2 }; var answer = a.combine(b, sum); answer.assign( $('#answer'), 'val');
NB. my way
in#a+p{ + }+in#b+p{ = `a_v+b_v`} NB. use i (or tb ta?) followed by type (nat, int, decimal, date, text; text is default for 'i'nput); only fires when valid term of type

NB. implicit functions attached to html tags
p{`1+1`} NB. set body of p to 2
p`1+1` NB. shorthand backticks (``) defaults to body
p:`log 1+1` NB. colon (:) uses default interaction for tag (hover for p tags); logs on hover
p:h`log 1+1` NB. same as above
p:hover`log 1+1` NB. same as above

NB. use event streams to get value from ajax calls (see bacon.js)

NB. all events are dropped if they occur before the latest event (see bacon flatmaplatest and frp semantics)

NB. apparently behaviours cannot have events embedded!? (since they are continuous?) https://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design 

NB. create a denotational design for this software

NB. body ({}) must go before click, so the click can modify the body
b#a{Foo}:{Bar}

NB. add the concept of recursion into the semantics
b#a{Foo}:{Bar}: = #a NB. the text will be Foo => Bar => Foo => Bar ...
b{Foo}:{Bar}:_ NB. use _ (or ..) for recurse (or self)?

NB. use click on one element to change another element
p#a{Change me}
b{Change above text}:#a = {Changed text}

NB. change background colour to red then blue
b@bred{Change color}:@bblue

NB. allow arbitrary colors by the following
p@bddd NB. set background to #dddddd
p@bdedede NB. set background to #dedede

NB. add animations along with time transformations

NB. should an element be placed when it is defined (like reflex)?
NB. probably not, otherwise components become more difficult

NB. should this be automated, otherwise have it composable and user-defineable
NB. login component requires sessions
NB. also include yesod's final destination feature (return to page which caused login)
/login = login

NB. functional components (n-ary args)
.card = @bglightblue
fcomp = .card>h3$$+p$$
fcomp{Card 1}{Hello}+fcomp{Card 2}{World!}

NB. code sent to the end user is only those features used in the app

NB. include a query language and db within web-dsl
NB. torel, project, select, rename, crossproduct, equality, union
NB. guess * is useful again?
/users = div>ul>li*>$users

NB. use db constraints to define the crud operations allowed for a type of user?

NB. use the following syntax for get and put/post/delete:
</form = #form>in+in+b
>/form = `log form`

NB. routes should be like yesod (ie "typesafe")
NB. the following causes an error since /bar is not defined
/foo = a[href=/bar]{Click to go to bar}
/baz = p{This is baz} 

NB. all information for a particular route is optimized in its delivery (perhaps by compiling into one file?)

NB. properly cache js and css files

NB. left side of assignment has urls in the following styles
/home = p{Hello World!}
</home = p{Hello World!}
<:3000/home = p{Hello World!}
<localhost:3000/home = p{Hello World!}
<http://www.localhost:3000/home = p{Hello World!}

NB. comments are the following
// this is a comment
NB. this is a special comment for specifying other more advanced options (port number etc) 
/// port=3000 

NB. routes
/ = a[href=/page1]{Go to page 1!} NB. root page
/page1 = a[href=/page2]{Go to page 2!}
/page2 = a[href=/]{Go home!}

NB. be able to send JSON data as well
/ = `'msg';'hello world'`

NB. prevent XSS (cross site scripting) attacks

NB. scoped css: all styles stay within the component they are defined in
@bgblue NB. global style, all routes
/foo = @bgblue NB. global for this route
bar = @bgblue NB. style only for this component

NB. route variables
/name/$name = p{Hello `$name`}
NB. typed route variables
/name/$name:text = p{Hello `$name`}
NB. url params (or can this be omitted for simplicity?)
/name?name=$name:text&age=$age:nat = p{Hello `$name`, aged `$age`.}
NB. simplified syntax (should there be $ before vars or not?)
/name?$name:text&$age:nat = p{Hello `$name`, aged `$age`.}
/name?name:text&age:nat = p{Hello `$name`, aged `$age`.}
NB. another example
</users?$sortby = `'sortby';sortby`

NB. allow for routes to send both html and json without creating a parse error
/ = h1{Message:}+p{Hello World!}
/ = `'msg';'hello world'`
NB. actually, have a different route for api (which will send json)
/     = h1{Message:}+p{Hello World!}
/api/ = `'msg';'hello world!'`


NB. be able to make api requests based on a link
/api/ = `'msg';'hello world!'`
/     = h1{Message:}+p{`'msg' get '/api/'`}
NB. or use the query syntax below with the link syntax
/     = h1{Message:}+p>/api?msg

NB. difference between > and {}?
NB. literal text body will be {} and > will denote a dom expression
p{hello world}
p>span{hi}

NB. create custom syntax for json

NB. use IHP as inspiration for web-dsl: https://ihp.digitallyinduced.com/Guide/your-first-project.html, see also ur/web

NB. what should the db syntax be?

</ = person NB. use the below table for generating the form
>/person = p{Person created `person`}
NB. create a table (default type of column to text)
NB. ? for optional, lots of predefined types, including html types such as color, email, url, etc
NB. by default, data can only be submitted once all requirements are met
%person'name,birthday:day,color:color?,email:email,website:url'
NB. can tables be first-class objects? if yes, use comma (,) to separate the columns (spaces optional)
NB. types separated by colon (:), optional value denoted by question mark (?)
person = name, birthday:day, color:color?, email:email, website:url

NB. how should rows be inserted into a table
NB. use function syntax?
person{Hassan}{march 11}{blue}{hassan@gmail.com}{c3g.nfshost.com}
NB. alternate function syntax
a = person{Hassan;march 11;blue;hassan@gmail.com;c3g.nfshost.com}
b = person{Maria;january 8;red;maria@gmail.com;fb.nfshost.com}
a union b
NB. make types mandatory, then last value with type is last column
person = name:text, birthday:day, color:color?, email:email, website:url, Hassan, march 11, blue, hassan@gmail.com, c3g.nfshost.com

NB. verify that function syntax and dom element body syntax is compatible

NB. what are the default datatypes in web-dsl?
NB. ints, nats, floats/doubles (use term used by J), strings

NB. autogen routes based on db tables
%personCRUD'name,birthday:day,color:color?,email:email,website:url'
NB. default to CRUD when tables are created
%person'name,birthday:day,color:color?,email:email,website:url'
NB. will create the following routes
>/create/person
</read/person
</readlist/person
>/update/person
>/delete/person

NB. Maybe values can be represented as an empty list that
NB. uses the * syntax to loop over; empty list expression being ignored
NB. without the *, the expression causes an error since it does not exist
html>head>title^body>*p{Your message was: $$}

NB. look to coffeescript for ideas on how the generated javascript should look like

NB. global styles (eg. below) affect everything, but component styles do not affect other components
@bgblue
h1{Hi}
foo = p@bgred{hi}
bar = p{hi}

NB. read ways to optimize the delivery and execution of web-dsl

NB. use domfragment to build dom tree, then insert all together into the full dom

NB. use event delegation to decrease the number of event listeners on the page
.foo>*.bar>p:c`log 'hi'`$$
NB. turns into
.foo:c`log baz`>*.bar>p.baz$$

NB. think about accessibility using the w3c docs wcag

NB. try to pre-render all javascript

NB. use < for parent operator since it is the opposite of child (>)

NB. automatically add image discriptions using ai

NB. have a relation/dom query operator
NB. relational query
person = name:text, birthday:day, color:color?, email:email, website:url, Hassan, march 11, blue, hassan@gmail.com, c3g.nfshost.com
NB. TODO
NB. dom query
a = .foo>.bar+.baz
NB. in a, find .baz and replace with .quux
a?.baz~.quux
NB. in a, find .baz's parent and replace with .quux
a = .foo>.bar+.baz
a?.baz<~.quux
NB. chaining modifications
a?.baz~.quux?.quux~.foo?.foo~.baz

NB. json query, retrive value c
obj = {
	a: {
		b: { 
			c: {}
		}
	}
}
obj?a?b?c
NB. or 
obj?a>b>c

NB. use regex for types or just create a type system?
nameorage = r`name|age`
nameorage = :name|age
/iam/$nameorage:nameorage = p{I am `$1:name`}+p{I am `$1:age` year(s) old}
NB. or use numbered case split
/iam/$nameorage:nameorage = p{I am `$1`}+p{I am `$2` year(s) old}


NB. nesting expressions
p{You can have i{italic} bold{bold} u{underlined} and span{spanned} text}

NB. create jwt tokens for authentication

NB. create plotting library using/similar to d3.js and the plot function in J

NB. other features that could be attempted
NB. all but first navigations should be instantaneous
NB. offline and progressive web app mode
NB. degrade gracefully when javascript is not available
NB. download only css/js that is required, then download rest in background

NB. use realworld example app to test web-dsl

NB. unused css and js removal and minification

NB. automatically generate sitemaps

NB. output should be semantic

NB. automatically generate swagger (api) description of the generated web app


NB. function syntax f(a)(b){c} paren for dom expr and brace for literal
NB. or allow domexprs as args in {}
foo = h1$$+p$$
foo{Hi}(span{hi})
foo = h1$$+$$
foo{Hi}(p>span{hi})

NB. keep web-dsl at a very high level, there should only be three parts NB. database layer, logic layer, presentation layer, 
NB. of which database, local storage, session storage, cookie, url params, ect are all in

NB. can GraphQL be done using a modified relational algebra?
NB. graphql
type Human {
  name: String
}
NB. web-dsl equivalent
human = name:s

NB. graphql
type Human {
  id: String
  name: String
  homePlanet: String
}
NB. web-dsl equivalent
human = id:s name:s homePlanet:s

NB. graphql
enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}
type Human {
  id: String
  name: String
  appearsIn: [Episode]
  homePlanet: String
}
NB. web-dsl equivalent
NB. `` before for constraints,
NB. in is defined as {{ (<x) e.~ cut y }}
human = `$3 in 'newhope empire jedi'` id:s name:s appearsIn:Ls homePlanet:s

NB. $num should use 0-indexed vars in currently defining rel

NB. how should escaping be done within ``? either `$ 1` (not `$1` which would refer to $1) to mean $1 in J or `\$1`
NB. the second works better if other things also need to be escaped
NB. I also hate the look of 'O''connell' => O'connell

NB. take another look at the Links and the ur/web programming languages
NB. also look at tablaM which is a relational programming language
NB. also look at sligh which converts essential logic into a full-stack web app and has a certifying source-to-source compiler

NB. use overloading to decrease the number of operators that are required (only do it if the op. and op: syntax can be completely removed from my lang?)
NB. 1 * 2 and student * teacher (relational join)

NB. forms can be automatically generated based on a relational expression
human = id:i name:s location:s
NB. would create a form with three inputs based on that schema

NB. having a haskell-like type system will help marshalling data and entering data into the system correctly (see above form generation)

NB. use type in url, then $num in the body
/foo/$i = `41 + $0`

NB. split code into front-end and backend automatically, see unison for distributed computations

NB. should sum types be added? it would add complexity and verboseness
NB. shouldn't it be possible to have a terse sum types?
:b = 0|1 NB. type of bool
/hungry/$b = ` +&3 \` *&12 $0 ` NB. use gerund ` and the first is used if the first construction is used; this is horrible

NB. what kind of effect system should this language use?

NB. all io functions should use the async functions, and be written the same way as normal J/Haskell

NB. add ranges to the type system
:w = 1..7

NB. how does K (kdb? q?) do relations?

NB. are maps just relations and/or should the syntax be similar?

NB. add wasm as a potential compilation target

NB. relational expressions are written in the rel lang, then converted into json if and when it is needed
NB. this would replace graphql (a query lang for json)
NB. graphql's many-to-many is problematic
NB. for example, join represent children in json, so a * b * c /= c * b * a because { data: a: { b: { c: {} } } } /= { data: c: { b: { a: {} } } }

NB. function types would be written like the following (if type inference fails or for documentation on function)
x:r NB. relation type
x:rr NB. rel -> rel; monadic func
x:rrr NB. rel -> rel -> rel;  dyadic func
x:srr NB. string -> rel -> rel
x:La NB. list of a (may be needed some times, but hopefully not, to keep it array oriented)
x:Lab NB. [a] -> b
NB. how would the list type be defined within the language

NB. api endpoints should just be considered global functions, and should be easily accessible through other functions
/foo/bar = .......
/foo/baz = /foo/bar
NB. the syntax of these is way too complicated, should it just use normal function names?
foo_bar NB. the _ could be used to delineate the parts
NB. but how would values be passed into the api? would I want to make it difficult or impossible (no leaky abstractions)?
NB. then this becomes easier
/foo/bar = .......
/foo/baz = ` 10 + foo_bar `

NB. values should be passed to the api endpoints as key-value pairs, perhaps like this `cut 'a 10 b 20'`
NB. there should be a way of accesssing these values

NB. the syntax that is created for this web language is starting to conflict with the J language
NB. perhaps the languages should start to diverge now?

NB. the whole language should be redesigned so that it goes from the abstract to slightly less
NB. based on what types of things are done using HTML+CSS+JS 
NB. see program refinements

NB. dyadic * can be used in the dom expr lang to account for empty arrays
NB. empty string and Nothing value are treated as emptiness as well
NB. equilvalent to `if (y == null || y.length == 0 || y == '' || y == Nothing) { x } else { c_1; foreach (e in y) { e }; c_2}`
(h1{Log in}+p{It seems you aren't logged in yet})*div>h1{Welcome Back!}+p$

NB. allow array left hand side for assignments
student teacher = sid sname * tid tname
NB. turns to
student = sid sname
teacher = tid tname
student_teacher_join = sid tid
studentTeacher = sid sname * tid tname
NB. or perhaps this makes more sense
studentTeacher = sid sname * tid tname
NB. turns to
student = sid sname
teacher = tid tname
student_teacher_join = sid tid
studentTeacher = sid sname * tid tname NB. as above!
NB. then 
student teacher = 10 20
NB. can be used to refer to pattern matching
NB. though the question remains if it should be haskell style (x:xs) or J style (length errors can occur)
NB. definitely J style (see below)

NB. the eval direction should be the same as J, ie. right to left
NB. even though dom exprs (div>p) might be written left to right, it can be thought of as wrapping everything to its right

NB. the UI should always show an indicator if an api call is taking too long processing in the background

NB. main features of graphql: single (data backend) endpoint, wraps both sql and nosql databases, data efficient

NB. what is the difference between symbols and variables in J

NB. should all api endpoints return html or html+rel?
NB. perhaps rel when called, and html+rel when viewed by the browser

NB. types are rank polymorphic using leading axis theory
NB. so [a] -> a => [[a]] -> [a]

NB. use the types to generate (selenium if required) test cases using property based testing (like quickcheck)
NB. somewhat similar to sligh, but this would allow for further changes of the transpiled/compiled program
NB. while ensuring components built with web-dsl would not break

NB. auto generate swagger docs

NB. use NB. for comments and NB: for docs, rather than the previous // and ///
NB. example for writing docs for the database
NB: $name lives at $location
person =: name location, 'hassan' 'pickering'
NB: $0 lives at $1
person =: name location, 'hassan' 'pickering'
NB: $ lives at $
person =: name location, 'hassan' 'pickering'

NB. allow nullable types within the rel lang by using haskell's maybe monad (for elegant chaining)

NB. all javascript features in the frontend should gracefully degrade when js is not available

NB. the types of names are allowed, pascal case, camel case, snake case
NB. actually use camel case all the time, but generate the url based on it if it is global
NB. fooBar =: ...... turns to /foo/bar api endpoint if it is a function
NB. fooBar =. ...... turns to fooBarV, fooBarE if it is a constant
NB. index.html turns to /index.html

NB. to have a complex syntax for values, require a space between values when they are of the complex syntactic type
+/i.10 NB. valid
+/ /foo NB. valid
+//foo NB. invalid, will be parsed as +// foo, whatever that means
+/ / NB. then this would mean the sum of the return value of the call to the root api endpoint?

NB. why does #a in {`#a`} mean events, while the syntax above allows for complex syntax for endpoints and that #a is clear that the var referenced is an id.
NB. since using just `a` makes it difficult to know where that var is coming from, and so there needs to be a a_id_ group (see nuvoc for name)
NB. perhaps using #a would be clearer, but it would also make it more verbose

NB. use session types to communicate between the client and server
NB. can this be automated, since the default should send data based on where that data originates
NB. for example, form data would go to the server, while api endpoints would send data to the client

NB. use haskell's types to give a simplified abstraction over REST apis
NB. for example, sending values of 'Maybe a' would decompose into 'a' if it is 'Just a' or give the proper 400s error code to the client
NB. see webmachine's decision tree for an example
NB. also take a look at servant

NB. allow definitions to be like this, to mean an unimplimented endpoint giving error code 500
/foo = _.
/foo NB. just by itself on a line will send an api request to /foo

NB. servant has authentication (see basic authentication on wikipedia)
/about NB. public
student@/courses NB. only student role permitted to access courses

NB. flesh out the details regarding roles, for example does it create relations in the db?

NB. add regex as a type; but should it be within strings or outside?

NB. what is the correct ratio of using things like regex as literals versus as strings?

NB. see links paper: Secure Compilation of a Multi-Tier Web Language
NB. from paper: A new class of multi-tier languages enables developers to mix client, server and database source code by shifting the burden of
NB. code and data partitioning to the compiler. LINKS is a strongly typed, multi-tier, functional programming language for the web
NB. (Cooper et al. 2006). From a single source file, the compiler gen- erates code for the different tiers of the web application: the back-
NB. end database, the web server and the client front-end, ensuring that all data is stored either on the client side or in the database.

NB. syntax for multiple arguments
mymacro{foo;bar} NB. ambigious, since the ; is part of a literal syntax
mymacro{foo`;`bar} NB. doesn't really mean anything
{foo}mymacro{bar} NB. perhaps the best option!

NB. am I just creating another Links, but with better syntax!?

NB. printing the output of any expression gets html-escaped, and all url-escaped (%20, etc) are decoded before being passed to the program
NB. p{<} => p{&lt;} and the same for code in inputs and from the user, it will never be evaled without being encoded to remove any potential meanings

NB. links
/foo = p{hi}
/bar = a[href=/foo]{Go to Foo}

NB. each channel created is typed and all data marshalling happens automatically

NB. channel syntax
createchannel cut 'client:d db:r'
'client' send p{hi}
'db' send student * teacher

NB. specifying relation types
db:r = sid sname * tid tname 
db:(i s i s) = sid sname * tid tname 
db = sid:i sname:s * tid:i tname:s          NB. the original turns out to be the shortest

NB. compare ur/web to web-dsl
table room : { Id : int, Title : string }
table message : { Room : int, When : time, Text : string }
room = id:i title:s
message = room:i when:t text:s

NB. apparently regular expression types are actually a thing! See Regular expression types for XML by Hosoyo et al.

NB. could web development be done with only J types, while adding concepts like session/linear types?

NB. have updatable views; how should this be done?
NB. it seems that functional dependencies (and integrity constraints) are required for having updatable views

NB. have typed and size indexed arrays
a:iA3 = 1 2 3 NB. valid
a:iA3 = 1 2   NB. invalid
a:(iA2-3) = 1 2   NB. valid
a:(iA2*3) = i. 2 3   NB. valid
a:A0-_ = 0$0 NB. valid
a:A0-_ = i. 10 NB. valid
a:A0-_ = i. 100000 NB. valid
a:A1-_ = 0$0 NB. invalid
a:A1-_ = 1 NB. valid
a:A1-_ = 1 2 3 4 5 NB. valid
a:A+ NB. same as a:A1-_
a:A? NB. same as a:A0-1

NB. use separate type for relations that are ordered or that are limited (first 10 results) https://github.com/agentm/project-m36/blob/master/docs/dataframes.markdown

NB. my concept of writing one program to be split and run everywhere is called tier-less programming
NB. and the concept of taking one session type and breaking it into multiple distributed computers that are inverses

NB. actually, types systems would probably get in the way of keeping the code concise
NB. the best way would be to annotate a few things, then have the compiler infer the rest (HM type inference), including potential optimizations (i32 vs i64)
NB. wasm doesn't even support small integer types, so perhaps there is a limit to what these optimizations can do

NB. could use bifunctor when using sum types
:foo = bar`baz NB. a foo is either a bar or a baz
a:foo NB. a has type of foo (is either a bar or a baz); should it be a:bar?
f a NB. apply f both when it is a bar and when it is a baz
*&2`+&3 a NB. apply *&2 if it is a bar, otherwise apply +&3 if it is a baz

NB. perhaps sum and product types can be modelled using the current J lang?
NB. let val_n and val_m be some data, where (type val_n) /= type val_m
NB. let sum => 
NB. 	left = val;a:
NB. 	right = a:;val
NB. let prod = val_n;val_m NB. disparate types require boxing
NB. based on the following reasoning:
NB. let a = a | null
NB. then a * b => 
NB. 	a * null => a
NB. 	null * b => b
NB. 	=> a | b

NB. hand-crafted version (lol)
NB: $ lives at $
NB. auto-generated version
NB. using the following example from chris date
NB. is_entity  ( SNO ) AND
NB. has_SNAME  ( SNO , SNAME ) AND
NB. has_STATUS ( SNO , STATUS ) AND
NB. has_CITY   ( SNO , CITY ) AND
NB. CITY = 'London'
NB: Entity $ has location $
person =: name location, 'hassan' 'pickering'
NB. in the following example all keys are considered part of the entity
NB: Entity $ and $, has course $
teaches =: #studentId #teacherId course, 'hassan' 'john' 'cs101'

NB. should there be special kinds of assignments?
NB. global vs local, mutable vs immutable (default), etc?

NB. allow the use of names rather than symbols for functions, ie. sum => +/

NB. rather than having ad-hoc polymorphism, perhaps rewriting NuVoc for web dev would be best?
NB. ie., student * teacher => student j. teacher, or perhaps student join teacher

NB. keep the languages as close to J as possible, for example the operator precedence
NB. eg. the @s in p@red{hi}+p@blue{hey} should be thought of as modifiers on the original dom element, to keep the operator precedence I want
NB. ie. p => p@red modifies the original dom element to also include some styling, similar to +/@:*/ and +/\
NB. the same should apply to keys in rel defs: student =: sid# sname such that the # suffix denotes that that col is a key (composite if used multiple times)
NB. ie. teaches:r =: studentId# teacherId# course

NB. what should something that modifies the same aspects of an element? eg. p@red@blue would this be red or blue? 
NB. most likely blue, though it could also be a warning/error only if it is applied directly to an element.
NB. allowed, since the blue and red are operating at different levels of specificity
@blue
p@red{hi}

NB. there are three ways of dealing with the relation problem, either nesting is implicit, nesting is explicit, or nesting is forbidden
NB. implicit
student join teachers
NB. explicit, where grouped is an adverb
student join grouped teachers
NB. though perhaps explicit should be this way, where j. is join and j: is grouped join
student j: teachers

NB. why do dom exprs have to have a parent element? can this be added automatically when needed?  p{hey}+p{hi} => div>p{hey}+p{hi}

NB. should dom exprs just be js code that is generated, or should they be considered a parsed string of type dom expr

NB. dom exprs should convert to normal html at compile-time

NB. look at how performant web app libraries are made, such as mithril, stage0, svelete, lit, mobx, and of course vanilla js

NB. nested sql example from leontrolski
SELECT NESTED { customer.name, customer.email, [ { product.id, product.cost, } ], sum(product.cost) AS total_cost, }
FROM customer LEFT OUTER JOIN NESTED product USING(customer_id) GROUP BY customer.customer_id
NB. my version (WIP)
'id' groupby 'total_cost =: +/cost' extend ('name email' p. customer) j: 'id cost' p. product


NB. mithril example
var root = document.body
var count = 0
var Hello = {
    view: function() {
        return m("main", [
            m("h1", {
                class: "title"
            }, "My first app"),
            m("button", {
                onclick: function() {count++}
            }, count + " clicks"),
        ])
    }
}
var Splash = {
    view: function() {
        return m("a", {
            href: "#!/hello"
        }, "Enter!")
    }
}
m.route(root, "/splash", {
    "/splash": Splash,
    "/hello": Hello,
})
NB. my style of creating complex html components
NB. should nullary functions (perhaps only for url functions) be allowed?
/hello = main>h1.title{My first app}+b#a{`#a` clicks}
/splash = a[href=/hello]{Enter!}
/splash''
NB. technically this would be preferred and simpler
/hello = main>h1.title{My first app}+b#a{`#a` clicks}
/ = a[href=/hello]{Enter!}

NB. an example of a web component; perhaps this can be used to create components that take multiple args?
<wc-arrow
	l=150 w=150 rot=20 filled=true>
</wc-arrow>  
NB. my style; still needs lots of work, for example what should be the default types (int/string), should boxed arrays be used, should rels be used 
wcarrow = div>p$+p$+p$+p$
/foo = wcarrow[150 150 20 1]

NB. the templating model needs to be updated with the nested relational model

NB. component in a dom expr should allow relations as an arg for the attrs

NB. name the attrs of the component for a one-off relation

NB. include fontawesome by default in web-dsl

NB. avoid web components since it uses (is it optional?) a shadow dom
NB. collisions (eg. in styling) can be avoided by giving ids to selectors ie #foo > ... 

NB. my style of creating complex html components; updated
wcarrow[s s s s] = dsv>p$+p$+p$+p$ NB. exactly 4 params where each is a string
NB. simplified (see url params for details); 4 goes later since it is a modifier; 
NB. length checks on arrays is probably going to be faster than on matrices; how should $ be referred within {``}?
wcarrow[s4] = div>p$+p$+p$+p$
/foo = wcarrow[150 150 20 1] NB. call syntax
wcarrow[i i s s] = div>p$+p$+p$+p$
/foo = wcarrow[150;150;'hi';'hello'] NB. boxed (heterogeneous) array, since types are different; unbox list by pattern matching
NB. boxed array with one nested array; ie a;b;c1 c2 => a;b;c1,.a;b;c2
wcarrow[i s] = div>p$+p$
/foo = wcarrow[(i. 3);'hey'] NB. converts to 0 1 2;'hey' => (0;'hey') , (1;'hey') ,: 2;'hey'
NB. boxed array with more than one nested array (cross product)
NB. relation as schema to args list; should the $ be the col names?
wcarrow[student] = div>p$+p$ NB. student was sid sname, ie. i s
NB. relation expression as schema to args list
wcarrow[studentTeacher] = div>p$+p$
NB. nested relation with one nested array (cross product)
NB. nested relation with more than one nested array (cross product)

NB. set global settings as either of these two ways
NB. a special comment at the top of the file
NB: foo=bar font=serif
NB. or as a global setting
@serif

NB. use system fonts by default rather than web fonts, unless explicitly specified

NB. dark mode should properly invert colors such that dark on bright becomes bright on dark

NB. @c for center x y, @cx for center x, @cy for center y, @c* for foreground colour

NB. attributes for html components must exist
foo[style=color:red] = .... NB. since style is a normal attr, it is not transformed, ie. style="color:red"; or should that be only on predefined elems?
foo[href=/hi] = .... NB. since href is allowed on all elements, it is not transformed (see htmx)
foo[data=1 2 3] = .... NB. data attr transforms to data-value
foo[bar=/hi] = .... NB. since bar is not a normal attr, it transforms to data-bar eqivalent in html 

NB. named attrs
foo[bar:i baz:i] = $bar + $baz
/hi = div>foo[bar=10 baz=20]
NB. array attrs (since it is an array oriented lang)
foo[data:i] = +/data
/hi = div>foo[data=i.3]
/hi = div>foo[i.3] NB. simplified

NB. https://latex.vercel.app/ for latex style (seems useful for J programmers)

p@cr NB. creates a p elem with red color; does this even make sense if it is not sent to the client? or should it be equivalent to / = p@cr, though forbidden?
p = p@cr NB. redefines p elem to always have the red color



NB. htmx
<!-- have a button POST a click via AJAX -->
<button hx-post="/clicked" hx-swap="outerHTML">
    Click Me
</button>
</ = b[post=/clicked]{Click Me}

NB. or should I just use the dom tree replacement operator (? was it) for it instead (assume it is for now)
>/clicked = p{You have been clicked!}
>/clicked = b?p{You have been clicked!} NB. should replacement only work either for current doc and/or previous doc?

NB. use htmx for this as well
/foo = h1{Hello World}+b:/bar{Click Here} NB. on default event (click) route to /bar
NB. can be changed to this, though it is slightly more verbose
/foo = h1{Hello World}+b[href=/bar]{Click Here} NB. on default event (click) route to /bar
/bar = h1{Hello, World!}+b[href=/foo]{Click Here again}

NB. pattern matching
a =: ... NB. normal def of either var or func
a,b =: ... NB. assign b and then do a,b
(a,b) =: ... NB. compute a 2 (atom/array/matrix on leading axis), assigning the first to a and the second to b
(a;b) =: ... NB. same as above, though top level must be boxed, and types may be different
f a =: ... NB. compute, then assign to a, then compute f(a)
a f b =: ... NB. same as above, though binary/dyadic

NB. send and receive syntax
send / = ...
/ = send ...
NB. this would not be allowed
/ = send ...
/ = receive ... NB. / has already been defined
NB. chained
/ = receive ... send ...
/ = receive ... [ send ...

NB. add dead code elimination

NB. automatically add rel=preload (or preconnect if the resource is definitly needed) to all external links
NB. "Bear in mind that while <link rel="preconnect"> is pretty cheap, it can
NB. still take up valuable CPU time, particularly on secure connections. This is
NB. especially bad if the connection isn't used within 10 seconds, as the browser
NB. closes it, wasting all of that early connection work."
<link rel="preload">
<link rel="preconnect" href="https://example.com">

NB. incremental loading of js like qwik if it is faster than bundling all js together
NB. though perhaps inlining css/js for above-the-fold, then async the rest, but that will make caching more difficult

NB. send the evaled code to the client, along with how to update it if js is enabled
b#a{+1}+b#b{-1}+p{Total: `(#a)-#b`}
NB. turns to
<button id="a">+1</button>
<button id="b">-1</button>
<p>Total: <span id="val">0</span></p>
<script>
	document.querySelector('#a').addEventListener('click', () => {
		val = document.querySelector('#val')
		val.innerText = parseInt(val.innerText) + 1
	})
	document.querySelector('#b').addEventListener('click', () => {
		val = document.querySelector('#val')
		val.innerText = parseInt(val.innerText) - 1
	})
</script>

NB. use push-pull reactive programming (conal elliot and frp) to see how laziness can be implemented

NB. it seems laziness (assuming js-on-demand, given stable internet) can be implemented as the following (from qwik)
<div on:input="./path-to-input-handler.js">
	<input value="hello"> <!-- the value "hello" is computed from the component's data store
</div>
<script> <!-- basically the only js needed on app startup, which will then pull the required functionality from the server -->
	for (const event of events) {
		document.addEventListener(event, e => {
			const target = e.target.closest(`on:${event}`)
			if (target) {
				const jsPath = target.getAttribute(`[on\\:${event}\`)
				import(jsPath).then(mod => mod.default(e))
			}
		})
	}
</script>

NB. break both css and js into the following categories: core (used everywhere), above-the-fold, page specific (keep separate if only js can be cached)

NB. progressive web apps seem to be the best option compared to rehydratable/resumable web apps
NB. since sending data across the network is the slowest compared to doing the computation yourself
NB. to get the best results with pwa, js should be kept to a minimum
NB. the biggest issue with pwa will be reconciling between both the server and the client modifying the same parts of the db


