Define a web server/client DSL:
use an emmet-like language for writing html-expressions along with J
examples and results written below

em '.foo#bar>ul>2*li' NB. create html based on expression
<div id="bar" class="foo">
	<ul>
 	<li></li>
 	<li></li>
 </ul>
</div>

NB. apply boxes on the right side (consistent with J and allows right-parened expressions)
(;: 'Hi didi') ap 'ul>*li{$}' NB. apply boxed array, looping on the starred subtree (not subexpression)
(;: 'Hi didi') ap 'ul>*li$'   NB. simplified syntax
<ul>
	<li>Hi</li>
	<li>didi</li>
</ul> 

(;: 'h1 p1 h2 p2') ap '*.page>h2$+p$' 
<div class="page">
	<h2>h1</h2>
	<p>p1</p>
</div>
<div class="page">
	<h2>h2</h2>
	<p>p2</p>
</div>

NB. get value from J
em 'h1{Hello $name}' ] name =: 'Hassan Shabbir'
<h1>Hello Hassan Shabbir</h1>

em 'h1{Hello $(|.name)}' ] name =: 'Hassan Shabbir' NB. J expressions in $()
<h1>Hello ribbahS nassaH</h1>

em 'img[src=www.google.com alt="an image"]' NB. attributes in [], space separated
<img src="www.google.com" alt="an image">

em 'p[style=$paraStyle]{hi}' NB. with paraStyle =: cut 'color purple font-family comic-sans,cursive font-size 2em'
<p style="color: purple; font-family: "Comic Sans", cursive; font-size: 2em;">hi</p>

em 'h1{hi}+$para' NB. para =: p{this is a paragraph} NB. components using variables in html positions
<h1>hi</h1>
<p>this is a paragraph</p>

em 'h1{hi}+3*$lorem' NB. lorem =: p{Lorem ipsum dolor sit amet} NB. lorem is a component
<h1>hi</h1>
<p>Lorem ipsum dolor sit amet</p>
<p>Lorem ipsum dolor sit amet</p>
<p>Lorem ipsum dolor sit amet</p>

em 'btn[clk=0:$v+1]{Clicked $v time$((v>1)?:'s')!}' NB. ?: is an if expression
<script>let v = 0;</script>
<button click="() => v = v+1">Clicked {v} time{v > 1 ? 's' : ''}!</button>

NB. $ extended to loop over boxed vectors; uses title case for props; as key-value pairs (also useful for styles)
em 'ul>*li{$obj}' ] obj =: ;: 'Name Hassan Age 23 Job Soft-dev City Pickering'
<ul>
  <li>Name: ${name}</li>
  <li>Age: ${age}</li>
  <li>Job: ${job}</li>
  <li>City: ${city}</li>
</ul>

em 'ul>li{$obj_name}' ] obj =: ;: 'Name Hassan Age 23 Job Soft-dev City Pickering' NB. get prop in object
<ul>
  <li>Name: ${name}</li>
  <li>Age: ${age}</li>
  <li>Job: ${job}</li>
  <li>City: ${city}</li>
</ul>

em 'btn[clk=$v+1]{$v doubled is $d}`v=0:+1;d=v*2`' NB. use `` for scripts; all vars that depend on referenced vars are auto updated
<script>let v = 0; let d = v * 2;</script>
<button click="() => v = v+1">{v} doubled is {d}</button>

NB. have a development and server version (ie dev =: 0 and dev =: 1)?

'/' serve em 'p{hello world}' NB. default port to 8080 and location to localhost (at least when dev =: 1)

'/didi' serve (;: 'Hi didi') ap 'ul>*li$' 

'/friends' serve (;: 'Aboo Mama Ahson Maria') ap 'h1{Your friends}+p{Here is a list of your friends:}+ul>*li$'

'/friend-details' serve (;: 'Aboo 60 Mama 57 Ahson 30 Maria 26') ap 'h1{Your friends}+p{Here is a list of your friends:}+ul>*li{$ ($ years old)}'

NB. differentiate between escaped and unescaped html code
NB. component support (place html,css,js in the correct spot in the DOM)
NB. automatic form generation and verification (including javascript verification) and parsing of put requests (into json object?)

NB. generate forms using the following expression
NB. seems like $_ at least will be needed to be able to reuse values more than once
(;: 'first-name last-name') ap 'form[action=/signup]>*(label[for=$]{$}+br+input#$[type=text name=$]+br)+input[type=submit value=Submit]'

t =: 4 3 $ ;: 'c1 c2 c3 b1 b2 b3 b4 b5 b6 b7 b8 b9'
NB. also add in sticky headers and zebra stripes
NB. num(tr) = rows - 1 (one is used for th); num(th) and num(td) = cols
em 'table>tr>th*3^tr*3>td*3'

NB. add in the ability to have nested components, like the following
em 'p{hi there my name is }+i{hassan}+p{how are you?}'
em 'p{hi there my name is i{hassan} how are you?}'

NB. default to placing the tags in the correct location (styles,title,meta in head, html in body, javascript at end of body)
NB. only include a library once (like JQuery)
NB. | splits between head (before |) and body (after |) and automatically move scripts to end of body if in the body
em 'title{my app}|script{console.log("hi")}+h1{this is my app}'

em 'title{title}+script[src=/included-in-head.js]|script[src=/included-in-body.js]'

NB. automatically add comments in generated html and css and uncompress code when in dev mode; add compression and minification and remove html/css comments

NB. components should be composable like the following:
a =: em 'h1[style="color:green;"]{My Title}' 
b =: em 'title{My page title}+script[src=http://www.example.com/script.js]' 
c =: em '$a+$b'

footer =: em 'footer[style="fwb tac"]>p{That is all folks!}'
page =: em 'p{my page.}+$footer'
NB. OR (without using components)
page =: em 'p{my page.}+footer[style="fwb tac"]>p{That is all folks!}'

section.blog[style='p1e b1s0 h1>c#ccf']

NB. define simplified notation that does not require the use of `[style='']` to define styles; for example:
section.blog%'p1e b1s0 h1>c#ccf'

NB. change ap to be reversed? (;: 'Hi didi') ap 'ul>*li{$}' => 'ul>*li{$}' ap ;: 'Hi didi'

NB. change serve function to get, post, put, delete functions

NB. @ is used as a suffix to refer to the sizes of screens, small, medium, large; in @[sml]{1,3}
p%'fs4em'@s%'fs3em'@m%'fs2em'@l
p%'fs3em'@sm

NB. define base url in a variable since it will be used to append to get, etc. as well as use in the base html tag

NB. remember to add this meta tag
meta[name=viewport content="width=device-width, initial-scale=1.0"]
meta[name=viewport content=width=device-width,initial-scale=1.0]

use the type system developed by Carol Tuttle to auto-design websites
for example, design =: 2 4, and have the css change based on that.
also give the ability to choose between the four components (different based on type) and the 
default chosen by the first type of design. ie:
$comp+$comp1+$comp2+$comp3+$comp4


NB. @ is used as a prefix to refer to the sizes of screens, small, medium, large; as in [sml]@
NB. this applies the rest of the styles to only those screen sizes
p%'s@fs4em'%'m@fs3em'%'l@fs2em'
p%'sm@fs3em'

NB. the design variable should be as follows: [1-4]([1-4][sm]){,2}
NB. where s stands for shape and m stands for movement
NB. eg. 2, 24m, 24s1m

NB. create a grid system with .g for creating 2-d grid, .r for creating a 1-d row
NB. with class .N referring to size out of 12 the element will take up
NB. .g is optional if only creating a row. .N is optional those elements will split
NB. the remaining space between themselves (1fr right?).

.r>img.3+p.9
<div class="r">
	<img class="3" src="" alt="">
	<p class="9"></p>
</div>

.g>.r>.a*3^.r>.a*3
<div class="g">
	<div class="r">
		<div class="a"></div>
		<div class="a"></div>
		<div class="a"></div>
	</div>
	<div class="r">
		<div class="a"></div>
		<div class="a"></div>
		<div class="a"></div>
	</div>
</div>

NB. create component functions such as the following:
NB. should components have multiple sections to interpolate into? (splats may be necessary)
NB. no, use nth value of tree if multiple values are needed
NB. use $$ for interpolation
NB. can looping and component definition be combined into one?
NB. use & to define component (auto-hidden subtree), and use $ to use it
'$footer{The fourth value comes from here}+&footer>.first>p{I}^.second>p{love}^.third>p{chocolate}^.fourth>p$$'
cta =: 'div>,' NB. or
cta =: 'div>,1+p{foo}+,2+,3'
$footer{.a}{.b}{.c} or as $footer{.a+.b+.c}
$cta{p{BUY, NOW!}+btn{BUY}} NB. call to action


NB. write about what influenced me
parenthesized expressions
(nav>.logo+.search+.button)+(.body>.page1+.page2+.page3)+(footer>.first+.second+.third)
eq without expression:

allow modifications within the language (toggle?)
.foo ~ #elem

think about how to combine javascript, J and a language to describe interactive functionality together

always dynamic values by default, then behaviour or event if needed

dynamically changing the value to be the number of clicks
references to elements become their event history in (reverse?) chronological order
name resolution order: id, class, html element, J var (therefore # and . can be continued to be used as J without disambiguation)
should a class name resolution combine all events from all selected elements, or those with a particular html element, or just the first element found with that class
button#b{Click me!}+p{You clicked the button `#b` times!} NB. count the number of events

last sent message
textarea#ta+button{Submit}+p{Your last sent message: `>{:>{:ta`.}

(dis)able button
checkbox#c{toggle}+submit[enabled=`>{:>{:c`]

Use _v (value) as a shortcut for >{:>{: and _e (event) for >{:
though other ones can be made such as first value _f* (1{) and previous value _p* ((n-1){)
textarea#ta+button{Submit}+p{Your last sent message: `ta_v`.}
ta+b{Submit}+p{Your last sent message: `ta_v`.}
checkbox#c{toggle}+submit[enabled=`c_v`]


Note that this does not work because a textarea should send an event on change
while the button submit only sends a click event, so then perhaps a form element
should contain sent events only when the submit button is pressed
form>ta+b{Submit}^p{Your last sent message: `ta_v`.}

dynamic attrs
gif =: 'rickAstley.gif'
img[src=gif]
OR should it be the following
img[src=`gif`]



svelte reactive assignments:
<script> let count = 0; function handleClick() { count += 1; } </script> <button on:click={handleClick}> Clicked {count} times </button>
my language example:
b{Clicked `#b` times}

svelte reactive declarations:
<script> let count = 1; $: doubled = count * 2; $: quadrupled = doubled * 2; function handleClick() { count += 1; } </script> <button on:click={handleClick}> Count: {count} </button> <p>{count} * 2 = {doubled}</p> <p>{doubled} * 2 = {quadrupled}</p>
my example:
b{Count: `#b`}+p{`#b` * 2 = `2*#b`}+p{`2*#b` * 2 = `4*#b`}


TODO: svelte reactive statements: (dont understand if expressions in J)
<script> let count = 0; $: if (count >= 10) { alert(`count is dangerously high!`); count = 9; } function handleClick() { count += 1; } </script> <button on:click={handleClick}> Clicked {count} times </button>


svelte looping over elements:
<script> let cats = [ { id: 'J---aiyznGQ', name: 'Keyboard Cat' }, { id: 'z_AbfPXTKms', name: 'Maru' }, { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' } ]; </script> 
<h1>The Famous Cats of YouTube</h1> <ul> {#each cats as { id, name }, i} <li><a target="_blank" href="https://www.youtube.com/watch?v={id}"> {i + 1}: {name} </a></li> {/each} </ul> 

my example: (use $# to refer to the ith loop)
'h1{The Famous Cats of YouTube}+ul>*li>a[href="https://www.youtube.com/watch?v=$$"]{$#: $$}' ap~ 'J---aiyznGQ';'Keyboard Cat';'z_AbfPXTKms';'Maru';'OUtn3pvWmpg';'Henri The Existential Cat'

negated
checkbox#c{toggle}+submit[enabled=`-.c_v`]


<script> let todos = [ { done: false, text: 'finish Svelte tutorial' }, { done: false, text: 'build an app' }, { done: false, text: 'world domination' } ]; </script> <h1>Todos</h1> {#each todos as todo} <div> <input type=checkbox bind:checked={todo.done} > <input bind:value={todo.text} disabled={todo.done} > </div> {/each}

note: change the data before passing it into the html portion if necessary
my example:
, 0 1 0 {"(1) 3 2 $ 0;'finish Svelte tutorial';0;'build an app';0;'world domination'
h1{Todos}+*div>checkbox[checked=$$]+textbox[value=$$ disabled=$$]


comparison with reflex-dom
{-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO() main = mainWidget $ do el "h1" $ text "Welcome to Reflex-Dom" el "div" $ do el "p" $ text "Reflex-Dom is:" el "ul" $ do el "li" $ text "Fun" el "li" $ text "Not difficult" el "li" $ text "Efficient"

h1{Welcome to Reflex-Dom}+div>p{Reflex-Dom is:}+ul>li{Fun}+li{Not difficult}+li{Efficient}

reflex-dom adding and subtracting using buttons:
{-# LANGUAGE RecursiveDo #-} {-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO () main = mainWidget bodyElement bodyElement :: MonadWidget t m => m () bodyElement = do rec counts <- foldDyn (+) (0 :: Int) $ leftmost [1 <$ evIncr, -1 <$ evDecr] el "div" $ display counts evIncr <- button "Increment" evDecr <- button "Decrement" return ()

b#a{Increment}+b#b{Decrement}+p{Total: `(#a)-#b`}

TODO reflex-dom combining event timelines:
{-# LANGUAGE RecursiveDo #-} {-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO () main = mainWidget bodyElement bodyElement :: MonadWidget t m => m () bodyElement = do el "h2" $ text "Using foldDyn with function application" rec dynNum <- foldDyn ($) (0 :: Int) $ leftmost [(+ 1) <$ evIncr, (+ (-1)) <$ evDecr, const 0 <$ evReset]  el "div" $ display dynNum evIncr <- button "Increment" evDecr <- button "Decrement" evReset <- button "Reset" return ()


to make the sorts (asc, desc) work, the first value in the event must be the timestamp of the occurrance
\:~ a,b,c

NB. use the dark reader firefox extesion to convert to a default dark mode value or vice versa

NB. apply styles using css selectors, as well as combinators (>^*~, etc)
p{hi} NB. creates p
p = .hi NB. sets all p to have hi class
p = {hi} NB. set all p body to hi, warn?
NB. therefore, p{hi} creates, p={hi} updates
NB. this is important otherwise data will be overwritten, eg.
.foo{Hi};.foo{Hello}

NB. what is the difference between ; (new command) and + (next sibling elem)
NB. should they be merged?

p = .bg-red-300 NB. sets all p to have red bg
p = .bg-red-300; #names = .bg-gray-200 NB. one-liner using ; evaluated left to right?
p = hi NB. error!
p = .bg-red-300 :hover.bg-red-600 NB. set multiple styles on one selector/element
#foo * = .red-300 NB. everything inside will have red text (recursive)

NB. use : to mean default interaction (click usually) and :hover for styles to apply on hover
#foo:hover.bg-red-300 NB. create foo id with red background only on hover
#foo:hover = .bg-red-300 NB. update foo to have this background on hover
#foo:hover.bg-red-300:focused.bg-red-400 NB. chain different effects
#foo:hover = .bg-red-300; #foo:focused = .bg-red-400

NB. determine a way of doing italics/bold/underline ie inline tags
p{foo b{bar} baz} => p{foo}+p.text-weight-800{bar}+p{baz} 
NB. should it use markdown styling?

NB. type system should be done with a special comment that defines the
following: 
1) general type (color, along with defaults of the rest), 
and only two (to determine the secondary) of the following:
2) design line (shapes)
3) texture
4) fabrication
5) pattern

NB. use @ to define styles rather than cluttering design with classes? 
NB. this can be said to be based on @apply I guess
NB. base the @command on the first letters of the two commands
NB. ie display:grid becomes @dg
NB. and padding-left:1rem; padding-right:1rem; becomes @px4
NB. create a scale that applies to all elements that does not have points

NB. use css reset, but only some parts (normalize.css)

NB. have an easy way of defining a grid (they should be very common)
NB. plus an easy way to define grid with elements centered

NB. all gen code should be responsive including things like typography

NB. set default styles in your file
h1 = .text-3xl.font-weight-800.text-gray-900

NB. check which ascii characters can be used
NB. create a language BNF

NB. how should elements be deleted, and how should dom traversal work

NB. how should components work?

NB. use scoped css (somewhat-)like in svelte: root styles affect everything,
NB. but component styling only affects the current component and not children

NB. also include the tag's properties as a map, ie. textarea_p
NB. for accessing the props such as colour?

value <- textArea; textBox $ fmap (++ "!") value
ta#i+p{`'!',~i_v`}

NB. React todo app
class TodoApp extends React.Component { constructor(props) { super(props); this.state = { items: [], text: '' }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } render() { return ( <div> <h3>TODO</h3> <TodoList items={this.state.items} /> <form onSubmit={this.handleSubmit}> <label htmlFor="new-todo"> What needs to be done?  </label> <input id="new-todo" onChange={this.handleChange} value={this.state.text} /> <button> Add #{this.state.items.length + 1} </button> </form> </div>); } handleChange(e) { this.setState({ text: e.target.value }); } handleSubmit(e) { e.preventDefault(); if (this.state.text.length === 0) { return; } const newItem = { text: this.state.text, id: Date.now() }; this.setState(state => ({ items: state.items.concat(newItem), text: '' })); } } class TodoList extends React.Component { render() { return ( <ul> {this.props.items.map(item => ( <li key={item.id}>{item.text}</li>))} </ul>); } } ReactDOM.render( <TodoApp />, document.getElementById('todos-example')); 
NB. svelte
<script> let newItem = ''; let todoList = [{text: 'Write my first post', status: true}, {text: 'Upload the post to the blog', status: false}, {text: 'Publish the post at Facebook', status: false}]; function addToList() { todoList = [...todoList, {text: newItem, status: false}]; newItem = ''; } function removeFromList(index) { todoList.splice(index, 1) todoList = todoList; } </script> <input bind:value={newItem} type="text" placeholder="new todo item.."> <button on:click={addToList}>Add</button> <br/> {#each todoList as item, index} <input bind:checked={item.status} type="checkbox"> <span class:checked={item.status}>{item.text}</span> <span on:click={() => removeFromList(index)}>❌</span> <br/> {/each} <style> .checked { text-decoration: line-through; } </style> 

NB. my design for todo app
NB. var z is used to refer to current value of item
todoList = ul>li$+li{`z , form_v`}
NB. or perhaps it should be like this?: todoList = ul>li$form_v which would append the value to the end of the list items
]todoApp = div>h3{TODO}+todoList{`;: 'hello world'`}+form>label{What needs to be done?}+input+button{Add `>:#input`}:s
NB. dense version (10% the size of the react version)
div>h3{TODO}+(ul>li$form_v)+form>label{What needs to be done?}+input+button{Add #`>:#input`}:s

NB. reactive component attached to input field; form values submitted on submit
div>h3{TODO}+(ul>li$form_v)+p{Length of text entered: `#input`}+form>label{What needs to be done?}+input+button{Add #`>:#input`}:s

NB. * seems to be quite useless when defining expressions, perhaps it should be removed, eg: 
ul>li*3; li[0] = {foo}; li[1] = {bar}; li[2] = {baz}
NB. compared to
ul>li{foo}+li{bar}+li{baz}
NB. or using emmets implied tags
ul>{foo}+{bar}+{baz}

NB. what was the syntax for events again?
b:c{Click me!}
NB. or
b[clk]{Click me!}

NB. linked pages are pages that replace one subtree for another subtree when an event fires in the first subtree
NB. use & for linking?
NB. should the linking be like this?
foo = .page#d>h1{Hello World}+b#a{Click Here}
bar = .page#b>h1{Hello, World!}+b#c{Click Here again}
#a&#b;#c&#d
NB. or like this?
foo = .page>h1{Hello World}+b{Click Here}
bar = .page>h1{Hello, World!}+b{Click Here again}
foo&bar
NB. actually this can be replaced by the routes syntax, such as the following
NB. how should other aspects be dealt with such as :c or the get/foo expanded syntaxes?
NB. routes defined similar to component definition (but prefixed with /)
/foo = h1{Hello World}+b:/bar{Click Here} NB. on default event (click) route to /bar
/bar = h1{Hello, World!}+b:/foo{Click Here again}

NB. every element should be dynamic by default and only static when explicitly stated

NB. concat two values of input fields
NB. change a_v style values to instead be aV (saves one char typing and one visual character spot as well)
ta#a+ta#b+p`aV,bV`

NB. count the total of increments and decrements
NB. bacon.js
var minusOnes = $('#minusOne').asEventStream('click').map(-1); var plusOnes = $('#plusOne').asEventStream('click').map(1); var score = minusOnes.merge(plusOnes).scan(0, (sum, value) => sum + value); score.assign($('#score'), 'text')
NB. my way
b#a{-1}+b#b{+1}+p{Total: `(#b)-#a`} NB. shouldn't the interactivity (and its type [hover, click]) be noted on the b(utton)?; is it possible to remove giving things ids?

NB. add numbers
NB. bacon.js
function inputVal(ev) { return $(ev.currentTarget).val() }; function isNumber(n) { return n > 0 }; var a = $('#a').asEventStream('keyup').map(inputVal).map(parseInt).filter(isNumber).toProperty(0); var b = $('#b').asEventStream('keyup').map(inputVal).map(parseInt).filter(isNumber).toProperty(0); function sum(arg1, arg2) { return arg1 + arg2 }; var answer = a.combine(b, sum); answer.assign( $('#answer'), 'val');
NB. my way
in#a+p{ + }+in#b+p{ = `a_v+b_v`} NB. use i (or tb ta?) followed by type (nat, int, decimal, date, text; text is default for 'i'nput); only fires when valid term of type

NB. implicit functions attached to html tags
p{`1+1`} NB. set body of p to 2
p`1+1` NB. shorthand backticks (``) defaults to body
p:`log 1+1` NB. colon (:) uses default interaction for tag (hover for p tags); logs on hover
p:h`log 1+1` NB. same as above
p:hover`log 1+1` NB. same as above

NB. use event streams to get value from ajax calls (see bacon.js)

NB. all events are dropped if they occur before the latest event (see bacon flatmaplatest and frp semantics)

NB. apparently behaviours cannot have events embedded!? (since they are continuous?) https://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design 

NB. create a denotational design for this software

NB. body ({}) must go before click, so the click can modify the body
b#a{Foo}:{Bar}

NB. add the concept of recursion into the semantics
b#a{Foo}:{Bar}: = #a NB. the text will be Foo => Bar => Foo => Bar ...
b{Foo}:{Bar}:_ NB. use _ (or ..) for recurse (or self)?

NB. use click on one element to change another element
p#a{Change me}
b{Change above text}:#a = {Changed text}

NB. change background colour to red then blue
b@bred{Change color}:@bblue

NB. allow arbitrary colors by the following
p@bddd NB. set background to #dddddd
p@bdedede NB. set background to #dedede

NB. add animations along with time transformations

NB. should an element be placed when it is defined (like reflex)?
NB. probably not, otherwise components become more difficult

NB. should this be automated, otherwise have it composable and user-defineable
NB. login component requires sessions
NB. also include yesod's final destination feature (return to page which caused login)
/login = login

NB. functional components (n-ary args)
.card = @bglightblue
fcomp = .card>h3$$+p$$
fcomp{Card 1}{Hello}+fcomp{Card 2}{World!}

NB. code sent to the end user is only those features used in the app

NB. include a query language and db within web-dsl
NB. torel, project, select, rename, crossproduct, equality, union
NB. guess * is useful again?
/users = div>ul>li*>$users

NB. use db constraints to define the crud operations allowed for a type of user?

NB. use the following syntax for get and put/post/delete:
</form = #form>in+in+b
>/form = `log form`

NB. routes should be like yesod (ie "typesafe")
NB. the following causes an error since /bar is not defined
/foo = a[href=/bar]{Click to go to bar}
/baz = p{This is baz} 

NB. all information for a particular route is optimized in its delivery (perhaps by compiling into one file?)

NB. properly cache js and css files

NB. left side of assignment has urls in the following styles
/home = p{Hello World!}
</home = p{Hello World!}
<:3000/home = p{Hello World!}
<localhost:3000/home = p{Hello World!}
<http://www.localhost:3000/home = p{Hello World!}

NB. comments are the following
// this is a comment
NB. this is a special comment for specifying other more advanced options (port number etc) 
/// port=3000 

NB. routes
/ = a[href=/page1]{Go to page 1!} NB. root page
/page1 = a[href=/page2]{Go to page 2!}
/page2 = a[href=/]{Go home!}

NB. be able to send JSON data as well
/ = `'msg';'hello world'`

NB. prevent XSS (cross site scripting) attacks

NB. scoped css: all styles stay within the component they are defined in
@bgblue NB. global style, all routes
/foo = @bgblue NB. global for this route
bar = @bgblue NB. style only for this component

NB. route variables
/name/$name = p{Hello `$name`}
NB. typed route variables
/name/$name:text = p{Hello `$name`}
NB. url params (or can this be omitted for simplicity?)
/name?name=$name:text&age=$age:nat = p{Hello `$name`, aged `$age`.}
NB. simplified syntax (should there be $ before vars or not?)
/name?$name:text&$age:nat = p{Hello `$name`, aged `$age`.}
/name?name:text&age:nat = p{Hello `$name`, aged `$age`.}
NB. another example
</users?$sortby = `'sortby';sortby`

NB. allow for routes to send both html and json without creating a parse error
/ = h1{Message:}+p{Hello World!}
/ = `'msg';'hello world'`
NB. actually, have a different route for api (which will send json)
/     = h1{Message:}+p{Hello World!}
/api/ = `'msg';'hello world!'`


NB. be able to make api requests based on a link
/api/ = `'msg';'hello world!'`
/     = h1{Message:}+p{`'msg' get '/api/'`}
NB. or use the query syntax below with the link syntax
/     = h1{Message:}+p>/api?msg

NB. difference between > and {}?
NB. literal text body will be {} and > will denote a dom expression
p{hello world}
p>span{hi}

NB. create custom syntax for json

NB. use IHP as inspiration for web-dsl: https://ihp.digitallyinduced.com/Guide/your-first-project.html, see also ur/web

NB. what should the db syntax be?

</ = person NB. use the below table for generating the form
>/person = p{Person created `person`}
NB. create a table (default type of column to text)
NB. ? for optional, lots of predefined types, including html types such as color, email, url, etc
NB. by default, data can only be submitted once all requirements are met
%person'name,birthday:day,color:color?,email:email,website:url'
NB. can tables be first-class objects? if yes, use comma (,) to separate the columns (spaces optional)
NB. types separated by colon (:), optional value denoted by question mark (?)
person = name, birthday:day, color:color?, email:email, website:url

NB. how should rows be inserted into a table
NB. use function syntax?
person{Hassan}{march 11}{blue}{hassan@gmail.com}{c3g.nfshost.com}
NB. alternate function syntax
a = person{Hassan;march 11;blue;hassan@gmail.com;c3g.nfshost.com}
b = person{Maria;january 8;red;maria@gmail.com;fb.nfshost.com}
a union b
NB. make types mandatory, then last value with type is last column
person = name:text, birthday:day, color:color?, email:email, website:url, Hassan, march 11, blue, hassan@gmail.com, c3g.nfshost.com

NB. verify that function syntax and dom element body syntax is compatible

NB. what are the default datatypes in web-dsl?
NB. ints, nats, floats/doubles (use term used by J), strings

NB. autogen routes based on db tables
%personCRUD'name,birthday:day,color:color?,email:email,website:url'
NB. default to CRUD when tables are created
%person'name,birthday:day,color:color?,email:email,website:url'
NB. will create the following routes
>/create/person
</read/person
</readlist/person
>/update/person
>/delete/person

NB. Maybe values can be represented as an empty list that
NB. uses the * syntax to loop over; empty list expression being ignored
NB. without the *, the expression causes an error since it does not exist
html>head>title^body>*p{Your message was: $$}

NB. look to coffeescript for ideas on how the generated javascript should look like

NB. global styles (eg. below) affect everything, but component styles do not affect other components
@bgblue
h1{Hi}
foo = p@bgred{hi}
bar = p{hi}

NB. read ways to optimize the delivery and execution of web-dsl

NB. use domfragment to build dom tree, then insert all together into the full dom

NB. use event delegation to decrease the number of event listeners on the page
.foo>*.bar>p:c`log 'hi'`$$
NB. turns into
.foo:c`log baz`>*.bar>p.baz$$

NB. think about accessibility using the w3c docs wcag

NB. try to pre-render all javascript

NB. use < for parent operator since it is the opposite of child (>)

NB. automatically add image discriptions using ai

NB. have a relation/dom query operator
NB. relational query
person = name:text, birthday:day, color:color?, email:email, website:url, Hassan, march 11, blue, hassan@gmail.com, c3g.nfshost.com
NB. TODO
NB. dom query
a = .foo>.bar+.baz
NB. in a, find .baz and replace with .quux
a?.baz~.quux
NB. in a, find .baz's parent and replace with .quux
a = .foo>.bar+.baz
a?.baz<~.quux
NB. chaining modifications
a?.baz~.quux?.quux~.foo?.foo~.baz

NB. json query, retrive value c
obj = {
	a: {
		b: { 
			c: {}
		}
	}
}
obj?a?b?c
NB. or 
obj?a>b>c

NB. use regex for types or just create a type system?
nameorage = r`name|age`
nameorage = :name|age
/iam/$nameorage:nameorage = p{I am `$1:name`}+p{I am `$1:age` year(s) old}
NB. or use numbered case split
/iam/$nameorage:nameorage = p{I am `$1`}+p{I am `$2` year(s) old}


NB. nesting expressions
p{You can have i{italic} bold{bold} u{underlined} and span{spanned} text}

NB. create jwt tokens for authentication

NB. create plotting library using/similar to d3.js and the plot function in J

NB. other features that could be attempted
NB. all but first navigations should be instantaneous
NB. offline and progressive web app mode
NB. degrade gracefully when javascript is not available
NB. download only css/js that is required, then download rest in background

NB. use realworld example app to test web-dsl

NB. unused css and js removal and minification

NB. automatically generate sitemaps

NB. output should be semantic

NB. automatically generate swagger (api) description of the generated web app


NB. function syntax f(a)(b){c} paren for dom expr and brace for literal
NB. or allow domexprs as args in {}
foo = h1$$+p$$
foo{Hi}(span{hi})
foo = h1$$+$$
foo{Hi}(p>span{hi})

NB. keep web-dsl at a very high level, there should only be three parts NB. database layer, logic layer, presentation layer, 
NB. of which database, local storage, session storage, cookie, url params, ect are all in

NB. can GraphQL be done using a modified relational algebra?
NB. graphql
type Human {
  name: String
}
NB. web-dsl equivalent
human = name:s

NB. graphql
type Human {
  id: String
  name: String
  homePlanet: String
}
NB. web-dsl equivalent
human = id:s name:s homePlanet:s

NB. graphql
enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}
type Human {
  id: String
  name: String
  appearsIn: [Episode]
  homePlanet: String
}
NB. web-dsl equivalent
NB. `` before for constraints,
NB. in is defined as {{ (<x) e.~ cut y }}
human = `$3 in 'newhope empire jedi'` id:s name:s appearsIn:Ls homePlanet:s

NB. $num should use 0-indexed vars in currently defining rel

NB. how should escaping be done within ``? either `$ 1` (not `$1` which would refer to $1) to mean $1 in J or `\$1`
NB. the second works better if other things also need to be escaped
NB. I also hate the look of 'O''connell' => O'connell

NB. take another look at the Links and the ur/web programming languages
NB. also look at tablaM which is a relational programming language
NB. also look at sligh which converts essential logic into a full-stack web app and has a certifying source-to-source compiler

NB. use overloading to decrease the number of operators that are required (only do it if the op. and op: syntax can be completely removed from my lang?)
NB. 1 * 2 and student * teacher (relational join)

NB. forms can be automatically generated based on a relational expression
human = id:i name:s location:s
NB. would create a form with three inputs based on that schema

NB. having a haskell-like type system will help marshalling data and entering data into the system correctly (see above form generation)

NB. use type in url, then $num in the body
/foo/$i = `41 + $0`

NB. split code into front-end and backend automatically, see unison for distributed computations

NB. should sum types be added? it would add complexity and verboseness
NB. shouldn't it be possible to have a terse sum types?
:b = 0|1 NB. type of bool
/hungry/$b = ` +&3 \` *&12 $0 ` NB. use gerund ` and the first is used if the first construction is used; this is horrible

NB. what kind of effect system should this language use?

NB. all io functions should use the async functions, and be written the same way as normal J/Haskell

NB. add ranges to the type system
:w = 1..7

NB. how does K (kdb? q?) do relations?

NB. are maps just relations and/or should the syntax be similar?

NB. add wasm as a potential compilation target

NB. relational expressions are written in the rel lang, then converted into json if and when it is needed
NB. this would replace graphql (a query lang for json)
NB. graphql's many-to-many is problematic
NB. for example, join represent children in json, so a * b * c /= c * b * a because { data: a: { b: { c: {} } } } /= { data: c: { b: { a: {} } } }

NB. function types would be written like the following (if type inference fails or for documentation on function)
x:r NB. relation type
x:rr NB. rel -> rel; monadic func
x:rrr NB. rel -> rel -> rel;  dyadic func
x:srr NB. string -> rel -> rel
x:La NB. list of a (may be needed some times, but hopefully not, to keep it array oriented)
x:Lab NB. [a] -> b
NB. how would the list type be defined within the language

NB. api endpoints should just be considered global functions, and should be easily accessible through other functions
/foo/bar = .......
/foo/baz = /foo/bar
NB. the syntax of these is way too complicated, should it just use normal function names?
foo_bar NB. the _ could be used to delineate the parts
NB. but how would values be passed into the api? would I want to make it difficult or impossible (no leaky abstractions)?
NB. then this becomes easier
/foo/bar = .......
/foo/baz = ` 10 + foo_bar `

NB. values should be passed to the api endpoints as key-value pairs, perhaps like this `cut 'a 10 b 20'`
NB. there should be a way of accesssing these values

NB. the syntax that is created for this web language is starting to conflict with the J language
NB. perhaps the languages should start to diverge now?

NB. the whole language should be redesigned so that it goes from the abstract to slightly less
NB. based on what types of things are done using HTML+CSS+JS 
NB. see program refinements

NB. dyadic * can be used in the dom expr lang to account for empty arrays
NB. empty string and Nothing value are treated as emptiness as well
NB. equilvalent to `if (y == null || y.length == 0 || y == '' || y == Nothing) { x } else { c_1; foreach (e in y) { e }; c_2}`
(h1{Log in}+p{It seems you aren't logged in yet})*div>h1{Welcome Back!}+p$

NB. allow array left hand side for assignments
student teacher = sid sname * tid tname
NB. turns to
student = sid sname
teacher = tid tname
student_teacher_join = sid tid

NB. the eval direction should be the same as J, ie. right to left
NB. even though dom exprs (div>p) might be written left to right, it can be thought of as wrapping everything to its right

NB. the UI should always show an indicator if an api call is taking too long processing in the background

NB. main features of graphql: single (data backend) endpoint, wraps both sql and nosql databases, data efficient

NB. what is the difference between symbols and variables in J

NB. should all api endpoints return html or html+rel?
NB. perhaps rel when called, and html+rel when viewed by the browser

NB. types are rank polymorphic using leading axis theory
NB. so [a] -> a == [[a]] -> [a]

NB. use the types to generate (selenium if required) test cases using property based testing (like quickcheck)
NB. somewhat similar to sligh, but this would allow for further changes of the transpiled/compiled program
NB. while ensuring components built with web-dsl would not break

NB. auto generate swagger docs

NB. use NB. for comments and NB: for docs, rather than the previous // and ///
NB. example for writing docs for the database
NB: $name lives at $location
person =: name location, 'hassan' 'pickering'
NB: $0 lives at $1
person =: name location, 'hassan' 'pickering'
NB: $ lives at $
person =: name location, 'hassan' 'pickering'

NB. allow nullable types within the rel lang by using haskell's maybe monad (for elegant chaining)

NB. all javascript features in the frontend should gracefully degrade when js is not available
