NB. Define a web server/client DSL:
NB. use an emmet-like language for writing html-expressions, and tailwind for css, and J for JS
NB. examples and results written below

em '.foo#bar>ul>2*li' NB. create html based on expression
<div id="bar" class="foo">
	<ul>
 	<li></li>
 	<li></li>
 </ul>
</div>

NB. apply boxes on the right side (consistent with J and allows right-parened expressions)
(;: 'Hi didi') ap 'ul>*li{$}' NB. apply boxed array, looping on the starred subtree (not subexpression)
(;: 'Hi didi') ap 'ul>*li$'   NB. simplified syntax
<ul>
	<li>Hi</li>
	<li>didi</li>
</ul> 

(;: 'h1 p1 h2 p2') ap '*.page>h2$+p$' 
<div class="page">
	<h2>h1</h2>
	<p>p1</p>
</div>
<div class="page">
	<h2>h2</h2>
	<p>p2</p>
</div>

NB. get value from J
em 'h1{Hello $name}' ] name =: 'Hassan Shabbir'
<h1>Hello Hassan Shabbir</h1>

em 'h1{Hello $(|.name)}' ] name =: 'Hassan Shabbir' NB. J expressions in $()
<h1>Hello ribbahS nassaH</h1>

em 'img[src=www.google.com alt="an image"]' NB. attributes in [], space separated
<img src="www.google.com" alt="an image">

em 'p[style=$paraStyle]{hi}' NB. with paraStyle =: cut 'color purple font-family comic-sans,cursive font-size 2em'
<p style="color: purple; font-family: "Comic Sans", cursive; font-size: 2em;">hi</p>

em 'h1{hi}+$para' NB. para =: p{this is a paragraph} NB. components using variables in html positions
<h1>hi</h1>
<p>this is a paragraph</p>

em 'h1{hi}+3*$lorem' NB. lorem =: p{Lorem ipsum dolor sit amet} NB. lorem is a component
<h1>hi</h1>
<p>Lorem ipsum dolor sit amet</p>
<p>Lorem ipsum dolor sit amet</p>
<p>Lorem ipsum dolor sit amet</p>

em 'btn[clk=0:$v+1]{Clicked $v time$((v>1)?:'s')!}' NB. ?: is an if expression
<script>let v = 0;</script>
<button click="() => v = v+1">Clicked {v} time{v > 1 ? 's' : ''}!</button>

NB. $ extended to loop over boxed vectors; uses title case for props; as key-value pairs (also useful for styles)
em 'ul>*li{$obj}' ] obj =: ;: 'Name Hassan Age 23 Job Soft-dev City Pickering'
<ul>
  <li>Name: ${name}</li>
  <li>Age: ${age}</li>
  <li>Job: ${job}</li>
  <li>City: ${city}</li>
</ul>

em 'ul>li{$obj_name}' ] obj =: ;: 'Name Hassan Age 23 Job Soft-dev City Pickering' NB. get prop in object
<ul>
  <li>Name: ${name}</li>
  <li>Age: ${age}</li>
  <li>Job: ${job}</li>
  <li>City: ${city}</li>
</ul>

em 'btn[clk=$v+1]{$v doubled is $d}`v=0:+1;d=v*2`' NB. use `` for scripts; all vars that depend on referenced vars are auto updated
<script>let v = 0; let d = v * 2;</script>
<button click="() => v = v+1">{v} doubled is {d}</button>

NB. have a development and server version (ie dev =: 0 and dev =: 1)?

'/' serve em 'p{hello world}' NB. default port to 8080 and location to localhost (at least when dev =: 1)

'/didi' serve (;: 'Hi didi') ap 'ul>*li$' 

'/friends' serve (;: 'Aboo Mama Ahson Maria') ap 'h1{Your friends}+p{Here is a list of your friends:}+ul>*li$'

'/friend-details' serve (;: 'Aboo 60 Mama 57 Ahson 30 Maria 26') ap 'h1{Your friends}+p{Here is a list of your friends:}+ul>*li{$ ($ years old)}'

NB. differentiate between escaped and unescaped html code
NB. component support (place html,css,js in the correct spot in the DOM)
NB. automatic form generation and verification (including javascript verification) and parsing of put requests (into json object?)

NB. generate forms using the following expression
NB. seems like $_ at least will be needed to be able to reuse values more than once
(;: 'first-name last-name') ap 'form[action=/signup]>*(label[for=$]{$}+br+input#$[type=text name=$]+br)+input[type=submit value=Submit]'

t =: 4 3 $ ;: 'c1 c2 c3 b1 b2 b3 b4 b5 b6 b7 b8 b9'
NB. also add in sticky headers and zebra stripes
NB. num(tr) = rows - 1 (one is used for th); num(th) and num(td) = cols
em 'table>tr>th*3^tr*3>td*3'

NB. add in the ability to have nested components, like the following
em 'p{hi there my name is }+i{hassan}+p{how are you?}'
em 'p{hi there my name is i{hassan} how are you?}'

NB. default to placing the tags in the correct location (styles,title,meta in head, html in body, javascript at end of body)
NB. only include a library once (like JQuery)
NB. | splits between head (before |) and body (after |) and automatically move scripts to end of body if in the body
em 'title{my app}|script{console.log("hi")}+h1{this is my app}'

em 'title{title}+script[src=/included-in-head.js]|script[src=/included-in-body.js]'

NB. automatically add comments in generated html and css and uncompress code when in dev mode; add compression and minification and remove html/css comments

NB. components should be composable like the following:
a =: em 'h1[style="color:green;"]{My Title}' 
b =: em 'title{My page title}+script[src=http://www.example.com/script.js]' 
c =: em '$a+$b'

footer =: em 'footer[style="fwb tac"]>p{That is all folks!}'
page =: em 'p{my page.}+$footer'
NB. OR (without using components)
page =: em 'p{my page.}+footer[style="fwb tac"]>p{That is all folks!}'

section.blog[style='p1e b1s0 h1>c#ccf']

NB. define simplified notation that does not require the use of `[style='']` to define styles; for example:
section.blog%'p1e b1s0 h1>c#ccf'

NB. change ap to be reversed? (;: 'Hi didi') ap 'ul>*li{$}' => 'ul>*li{$}' ap ;: 'Hi didi'

NB. change serve function to get, post, put, delete functions

NB. @ is used as a suffix to refer to the sizes of screens, small, medium, large; in @[sml]{1,3}
p%'fs4em'@s%'fs3em'@m%'fs2em'@l
p%'fs3em'@sm

NB. define base url in a variable since it will be used to append to get, etc. as well as use in the base html tag

NB. remember to add this meta tag
meta[name=viewport content="width=device-width, initial-scale=1.0"]
meta[name=viewport content=width=device-width,initial-scale=1.0]

use the type system developed by Carol Tuttle to auto-design websites
for example, design =: 2 4, and have the css change based on that.
also give the ability to choose between the four components (different based on type) and the 
default chosen by the first type of design. ie:
$comp+$comp1+$comp2+$comp3+$comp4


NB. @ is used as a prefix to refer to the sizes of screens, small, medium, large; as in [sml]@
NB. this applies the rest of the styles to only those screen sizes
p%'s@fs4em'%'m@fs3em'%'l@fs2em'
p%'sm@fs3em'

NB. the design variable should be as follows: [1-4]([1-4][sm]){,2}
NB. where s stands for shape and m stands for movement
NB. eg. 2, 24m, 24s1m

NB. create a grid system with .g for creating 2-d grid, .r for creating a 1-d row
NB. with class .N referring to size out of 12 the element will take up
NB. .g is optional if only creating a row. .N is optional those elements will split
NB. the remaining space between themselves (1fr right?).

.r>img.3+p.9
<div class="r">
	<img class="3" src="" alt="">
	<p class="9"></p>
</div>

.g>.r>.a*3^.r>.a*3
<div class="g">
	<div class="r">
		<div class="a"></div>
		<div class="a"></div>
		<div class="a"></div>
	</div>
	<div class="r">
		<div class="a"></div>
		<div class="a"></div>
		<div class="a"></div>
	</div>
</div>

NB. create component functions such as the following:
NB. should components have multiple sections to interpolate into? (splats may be necessary)
NB. no, use nth value of tree if multiple values are needed
NB. use $$ for interpolation
NB. can looping and component definition be combined into one?
NB. use & to define component (auto-hidden subtree), and use $ to use it
'$footer{The fourth value comes from here}+&footer>.first>p{I}^.second>p{love}^.third>p{chocolate}^.fourth>p$$'
cta =: 'div>,' NB. or
cta =: 'div>,1+p{foo}+,2+,3'
$footer{.a}{.b}{.c} or as $footer{.a+.b+.c}
$cta{p{BUY, NOW!}+btn{BUY}} NB. call to action


NB. write about what influenced me or the things that were my inspiration/sources

parenthesized expressions
(nav>.logo+.search+.button)+(.body>.page1+.page2+.page3)+(footer>.first+.second+.third)
eq without expression:
nav>.logo+.search+.button^.body>.page1+.page2+.page3^footer>.first+.second+.third
html:
<nav>
	<div class="logo"></div>
	<div class="search"></div>
	<div class="button"></div>
</nav>
<div class="body">
	<div class="page1"></div>
	<div class="page2"></div>
	<div class="page3"></div>
</div>
<footer>
	<div class="first"></div>
	<div class="second"></div>
	<div class="third"></div>
</footer>


allow modifications within the language (toggle?)
.foo ~ #elem

think about how to combine javascript, J and a language to describe interactive functionality together

always dynamic values by default, then behaviour or event if needed

dynamically changing the value to be the number of clicks
references to elements become their event history in (reverse?) chronological order
name resolution order: id, class, html element, J var (therefore # and . can be continued to be used as J without disambiguation)
should a class name resolution combine all events from all selected elements, or those with a particular html element, or just the first element found with that class
button#b{Click me!}+p{You clicked the button `#b` times!} NB. count the number of events

last sent message
textarea#ta+button{Submit}+p{Your last sent message: `>{:>{:ta`.}

(dis)able button
checkbox#c{toggle}+submit[enabled=`>{:>{:c`]

Use _v (value) as a shortcut for >{:>{: and _e (event) for >{:
though other ones can be made such as first value _f* (1{) and previous value _p* ((n-1){)
textarea#ta+button{Submit}+p{Your last sent message: `ta_v`.}
ta+b{Submit}+p{Your last sent message: `ta_v`.}
checkbox#c{toggle}+submit[enabled=`c_v`]


Note that this does not work because a textarea should send an event on change
while the button submit only sends a click event, so then perhaps a form element
should contain sent events only when the submit button is pressed
form>ta+b{Submit}^p{Your last sent message: `ta_v`.}

dynamic attrs
gif =: 'rickAstley.gif'
img[src=gif]
OR should it be the following
img[src=`gif`]



svelte reactive assignments:
<script> let count = 0; function handleClick() { count += 1; } </script> <button on:click={handleClick}> Clicked {count} times </button>
my language example:
b{Clicked `#b` times}

svelte reactive declarations:
<script> let count = 1; $: doubled = count * 2; $: quadrupled = doubled * 2; function handleClick() { count += 1; } </script> <button on:click={handleClick}> Count: {count} </button> <p>{count} * 2 = {doubled}</p> <p>{doubled} * 2 = {quadrupled}</p>
my example:
b{Count: `#b`}+p{`#b` * 2 = `2*#b`}+p{`2*#b` * 2 = `4*#b`}


TODO: svelte reactive statements: (dont understand if expressions in J)
<script> let count = 0; $: if (count >= 10) { alert(`count is dangerously high!`); count = 9; } function handleClick() { count += 1; } </script> <button on:click={handleClick}> Clicked {count} times </button>


svelte looping over elements:
<script> let cats = [ { id: 'J---aiyznGQ', name: 'Keyboard Cat' }, { id: 'z_AbfPXTKms', name: 'Maru' }, { id: 'OUtn3pvWmpg', name: 'Henri The Existential Cat' } ]; </script> 
<h1>The Famous Cats of YouTube</h1> <ul> {#each cats as { id, name }, i} <li><a target="_blank" href="https://www.youtube.com/watch?v={id}"> {i + 1}: {name} </a></li> {/each} </ul> 

my example: (use $# to refer to the ith loop)
'h1{The Famous Cats of YouTube}+ul>*li>a[href="https://www.youtube.com/watch?v=$$"]{$#: $$}' ap~ 'J---aiyznGQ';'Keyboard Cat';'z_AbfPXTKms';'Maru';'OUtn3pvWmpg';'Henri The Existential Cat'

negated
checkbox#c{toggle}+submit[enabled=`-.c_v`]


<script> let todos = [ { done: false, text: 'finish Svelte tutorial' }, { done: false, text: 'build an app' }, { done: false, text: 'world domination' } ]; </script> <h1>Todos</h1> {#each todos as todo} <div> <input type=checkbox bind:checked={todo.done} > <input bind:value={todo.text} disabled={todo.done} > </div> {/each}

note: change the data before passing it into the html portion if necessary
my example:
, 0 1 0 {"(1) 3 2 $ 0;'finish Svelte tutorial';0;'build an app';0;'world domination'
h1{Todos}+*div>checkbox[checked=$$]+textbox[value=$$ disabled=$$]


comparison with reflex-dom
{-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO() main = mainWidget $ do el "h1" $ text "Welcome to Reflex-Dom" el "div" $ do el "p" $ text "Reflex-Dom is:" el "ul" $ do el "li" $ text "Fun" el "li" $ text "Not difficult" el "li" $ text "Efficient"

h1{Welcome to Reflex-Dom}+div>p{Reflex-Dom is:}+ul>li{Fun}+li{Not difficult}+li{Efficient}

reflex-dom adding and subtracting using buttons:
{-# LANGUAGE RecursiveDo #-} {-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO () main = mainWidget bodyElement bodyElement :: MonadWidget t m => m () bodyElement = do rec counts <- foldDyn (+) (0 :: Int) $ leftmost [1 <$ evIncr, -1 <$ evDecr] el "div" $ display counts evIncr <- button "Increment" evDecr <- button "Decrement" return ()

b#a{Increment}+b#b{Decrement}+p{Total: `(#a)-#b`}

TODO reflex-dom combining event timelines:
{-# LANGUAGE RecursiveDo #-} {-# LANGUAGE OverloadedStrings #-} import Reflex.Dom main :: IO () main = mainWidget bodyElement bodyElement :: MonadWidget t m => m () bodyElement = do el "h2" $ text "Using foldDyn with function application" rec dynNum <- foldDyn ($) (0 :: Int) $ leftmost [(+ 1) <$ evIncr, (+ (-1)) <$ evDecr, const 0 <$ evReset]  el "div" $ display dynNum evIncr <- button "Increment" evDecr <- button "Decrement" evReset <- button "Reset" return ()


to make the sorts (asc, desc) work, the first value in the event must be the timestamp of the occurrance
\:~ a,b,c

NB. use the dark reader firefox extesion to convert to a default dark mode value or vice versa
NB. they actually provide an api! "You can use Dark Reader to enable dark mode on your website!"

NB. apply styles using css selectors, as well as combinators (>^*~, etc)
p{hi} NB. creates p
p = .hi NB. sets all p to have hi class
p = {hi} NB. set all p body to hi, warn?
NB. therefore, p{hi} creates, p={hi} updates
NB. this is important otherwise data will be overwritten, eg.
.foo{Hi};.foo{Hello}

NB. what is the difference between ; (new command) and + (next sibling elem)
NB. should they be merged?
NB. nevermind, new command not needed (or use [ or ] from J), but newlines if allowed would append htmlexpr to the end of inside the body tag (right before the closing body tag)

p = .bg-red-300 NB. sets all p to have red bg
p = .bg-red-300; #names = .bg-gray-200 NB. one-liner using ; evaluated left to right?
p = hi NB. error!
p = .bg-red-300 :hover.bg-red-600 NB. set multiple styles on one selector/element
#foo * = .red-300 NB. everything inside will have red text (recursive)

NB. use : to mean default interaction (click usually) and :hover for styles to apply on hover
#foo:hover.bg-red-300 NB. create foo id with red background only on hover
#foo:hover = .bg-red-300 NB. update foo to have this background on hover
#foo:hover.bg-red-300:focused.bg-red-400 NB. chain different effects
#foo:hover = .bg-red-300; #foo:focused = .bg-red-400

NB. determine a way of doing italics/bold/underline ie inline tags
p{foo b{bar} baz} => p{foo}+p.text-weight-800{bar}+p{baz} 
NB. should it use markdown styling?

NB. type system should be done with a special comment that defines the
following: 
1) general type (color, along with defaults of the rest), 
and only two (to determine the secondary) of the following:
2) design line (shapes)
3) texture
4) fabrication
5) pattern

NB. use @ to define styles rather than cluttering design with classes? 
NB. this can be said to be based on @apply I guess
NB. base the @command on the first letters of the two commands
NB. ie display:grid becomes @dg
NB. and padding-left:1rem; padding-right:1rem; becomes @px4
NB. create a scale that applies to all elements that does not have points

NB. use css reset, but only some parts (normalize.css)

NB. have an easy way of defining a grid (they should be very common)
NB. plus an easy way to define grid with elements centered

NB. all gen code should be responsive including things like typography

NB. set default styles in your file
h1 = .text-3xl.font-weight-800.text-gray-900

NB. check which ascii characters can be used
NB. create a language BNF

NB. how should elements be deleted, and how should dom traversal work

NB. how should components work?

NB. use scoped css (somewhat-)like in svelte: root styles affect everything,
NB. but component styling only affects the current component and not children

NB. also include the tag's properties as a map, ie. textarea_p
NB. for accessing the props such as colour?

value <- textArea; textBox $ fmap (++ "!") value
ta#i+p{`'!',~i_v`}

NB. React todo app
class TodoApp extends React.Component { constructor(props) { super(props); this.state = { items: [], text: '' }; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } render() { return ( <div> <h3>TODO</h3> <TodoList items={this.state.items} /> <form onSubmit={this.handleSubmit}> <label htmlFor="new-todo"> What needs to be done?  </label> <input id="new-todo" onChange={this.handleChange} value={this.state.text} /> <button> Add #{this.state.items.length + 1} </button> </form> </div>); } handleChange(e) { this.setState({ text: e.target.value }); } handleSubmit(e) { e.preventDefault(); if (this.state.text.length === 0) { return; } const newItem = { text: this.state.text, id: Date.now() }; this.setState(state => ({ items: state.items.concat(newItem), text: '' })); } } class TodoList extends React.Component { render() { return ( <ul> {this.props.items.map(item => ( <li key={item.id}>{item.text}</li>))} </ul>); } } ReactDOM.render( <TodoApp />, document.getElementById('todos-example')); 
NB. svelte
<script> let newItem = ''; let todoList = [{text: 'Write my first post', status: true}, {text: 'Upload the post to the blog', status: false}, {text: 'Publish the post at Facebook', status: false}]; function addToList() { todoList = [...todoList, {text: newItem, status: false}]; newItem = ''; } function removeFromList(index) { todoList.splice(index, 1) todoList = todoList; } </script> <input bind:value={newItem} type="text" placeholder="new todo item.."> <button on:click={addToList}>Add</button> <br/> {#each todoList as item, index} <input bind:checked={item.status} type="checkbox"> <span class:checked={item.status}>{item.text}</span> <span on:click={() => removeFromList(index)}>‚ùå</span> <br/> {/each} <style> .checked { text-decoration: line-through; } </style> 

NB. my design for todo app
NB. var z is used to refer to current value of item
todoList = ul>li$+li{`z , form_v`}
NB. or perhaps it should be like this?: todoList = ul>li$form_v which would append the value to the end of the list items
]todoApp = div>h3{TODO}+todoList{`;: 'hello world'`}+form>label{What needs to be done?}+input+button{Add `>:#input`}:s
NB. dense version (10% the size of the react version)
div>h3{TODO}+(ul>li$form_v)+form>label{What needs to be done?}+input+button{Add #`>:#input`}:s

NB. reactive component attached to input field; form values submitted on submit
div>h3{TODO}+(ul>li$form_v)+p{Length of text entered: `#input`}+form>label{What needs to be done?}+input+button{Add #`>:#input`}:s

NB. * seems to be quite useless when defining expressions, perhaps it should be removed, eg: 
ul>li*3; li[0] = {foo}; li[1] = {bar}; li[2] = {baz}
NB. compared to
ul>li{foo}+li{bar}+li{baz}
NB. or using emmets implied tags
ul>{foo}+{bar}+{baz}

NB. what was the syntax for events again?
b:c{Click me!}
NB. or
b[clk]{Click me!}

NB. linked pages are pages that replace one subtree for another subtree when an event fires in the first subtree
NB. use & for linking?
NB. should the linking be like this?
foo = .page#d>h1{Hello World}+b#a{Click Here}
bar = .page#b>h1{Hello, World!}+b#c{Click Here again}
#a&#b;#c&#d
NB. or like this?
foo = .page>h1{Hello World}+b{Click Here}
bar = .page>h1{Hello, World!}+b{Click Here again}
foo&bar
NB. actually this can be replaced by the routes syntax, such as the following
NB. how should other aspects be dealt with such as :c or the get/foo expanded syntaxes?
NB. routes defined similar to component definition (but prefixed with /)
/foo = h1{Hello World}+b:/bar{Click Here} NB. on default event (click) route to /bar
/bar = h1{Hello, World!}+b:/foo{Click Here again}

NB. every element should be dynamic by default and only static (constant) when explicitly stated

NB. concat two values of input fields
NB. change a_v style values to instead be aV (saves one char typing and one visual character spot as well)
ta#a+ta#b+p`aV,bV`
NB. this is what is should be like (preferrably), actually: ta,ta (ie. create an input, create another input, then join the values of both as an output field

NB. count the total of increments and decrements
NB. bacon.js
var minusOnes = $('#minusOne').asEventStream('click').map(-1); var plusOnes = $('#plusOne').asEventStream('click').map(1); var score = minusOnes.merge(plusOnes).scan(0, (sum, value) => sum + value); score.assign($('#score'), 'text')
NB. my way
b#a{-1}+b#b{+1}+p{Total: `(#b)-#a`} NB. shouldn't the interactivity (and its type [hover, click]) be noted on the b(utton)?; is it possible to remove giving things ids?

NB. add numbers
NB. bacon.js
function inputVal(ev) { return $(ev.currentTarget).val() }; function isNumber(n) { return n > 0 }; var a = $('#a').asEventStream('keyup').map(inputVal).map(parseInt).filter(isNumber).toProperty(0); var b = $('#b').asEventStream('keyup').map(inputVal).map(parseInt).filter(isNumber).toProperty(0); function sum(arg1, arg2) { return arg1 + arg2 }; var answer = a.combine(b, sum); answer.assign( $('#answer'), 'val');
NB. my way
in#a+p{ + }+in#b+p{ = `a_v+b_v`} NB. use i (or tb ta?) followed by type (nat, int, decimal, date, text; text is default for 'i'nput); only fires when valid term of type

NB. implicit functions attached to html tags
p{`1+1`} NB. set body of p to 2
p`1+1` NB. shorthand backticks (``) defaults to body
p:`log 1+1` NB. colon (:) uses default interaction for tag (hover for p tags); logs on hover
p:h`log 1+1` NB. same as above
p:hover`log 1+1` NB. same as above

NB. use event streams to get value from ajax calls (see bacon.js)

NB. all events are dropped if they occur before the latest event (see bacon flatmaplatest and frp semantics)

NB. apparently behaviours cannot have events embedded!? (since they are continuous?) https://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design 

NB. create a denotational design for this software

NB. body ({}) must go before click, so the click can modify the body
b#a{Foo}:{Bar}

NB. add the concept of recursion into the semantics
b#a{Foo}:{Bar}: = #a NB. the text will be Foo => Bar => Foo => Bar ...
b{Foo}:{Bar}:_ NB. use _ (or ..) for recurse (or self)?

NB. use click on one element to change another element
p#a{Change me}
b{Change above text}:#a = {Changed text}

NB. change background colour to red then blue
b@bred{Change color}:@bblue

NB. allow arbitrary colors by the following
p@bddd NB. set background to #dddddd
p@bdedede NB. set background to #dedede

NB. add animations along with time transformations

NB. should an element be placed when it is defined (like reflex)?
NB. probably not, otherwise components become more difficult

NB. should this be automated, otherwise have it composable and user-defineable
NB. login component requires sessions
NB. also include yesod's final destination feature (return to page which caused login)
/login = login

NB. functional components (n-ary args)
.card = @bglightblue
fcomp = .card>h3$$+p$$
fcomp{Card 1}{Hello}+fcomp{Card 2}{World!}

NB. code sent to the end user is only those features used in the app

NB. include a query language and db within web-dsl
NB. torel, project, select, rename, crossproduct, equality, union
NB. guess * is useful again?
/users = div>ul>li*>$users

NB. use db constraints to define the crud operations allowed for a type of user?

NB. use the following syntax for get and put/post/delete:
</form = #form>in+in+b
>/form = `log form`

NB. routes should be like yesod (ie "typesafe")
NB. the following causes an error since /bar is not defined
/foo = a[href=/bar]{Click to go to bar}
/baz = p{This is baz} 

NB. all information for a particular route is optimized in its delivery (perhaps by compiling into one file?)

NB. properly cache js and css files

NB. left side of assignment has urls in the following styles
/home = p{Hello World!}
</home = p{Hello World!}
<:3000/home = p{Hello World!}
<localhost:3000/home = p{Hello World!}
<http://www.localhost:3000/home = p{Hello World!}

NB. comments are the following
// this is a comment
NB. this is a special comment for specifying other more advanced options (port number etc) 
/// port=3000 

NB. routes
/ = a[href=/page1]{Go to page 1!} NB. root page
/page1 = a[href=/page2]{Go to page 2!}
/page2 = a[href=/]{Go home!}

NB. be able to send JSON data as well
/ = `'msg';'hello world'`

NB. prevent XSS (cross site scripting) attacks

NB. scoped css: all styles stay within the component they are defined in
@bgblue NB. global style, all routes
/foo = @bgblue NB. global for this route
bar = @bgblue NB. style only for this component

NB. route variables
/name/$name = p{Hello `$name`}
NB. typed route variables
/name/$name:text = p{Hello `$name`}
NB. url params (or can this be omitted for simplicity?)
/name?name=$name:text&age=$age:nat = p{Hello `$name`, aged `$age`.}
NB. simplified syntax (should there be $ before vars or not?)
/name?$name:text&$age:nat = p{Hello `$name`, aged `$age`.}
/name?name:text&age:nat = p{Hello `$name`, aged `$age`.}
NB. another example
</users?$sortby = `'sortby';sortby`

NB. allow for routes to send both html and json without creating a parse error
/ = h1{Message:}+p{Hello World!}
/ = `'msg';'hello world'`
NB. actually, have a different route for api (which will send json)
/     = h1{Message:}+p{Hello World!}
/api/ = `'msg';'hello world!'`


NB. be able to make api requests based on a link
/api/ = `'msg';'hello world!'`
/     = h1{Message:}+p{`'msg' get '/api/'`}
NB. or use the query syntax below with the link syntax
/     = h1{Message:}+p>/api?msg

NB. difference between > and {}?
NB. literal text body will be {} and > will denote a dom expression
p{hello world}
p>span{hi}

NB. create custom syntax for json

NB. use IHP as inspiration for web-dsl: https://ihp.digitallyinduced.com/Guide/your-first-project.html, see also ur/web

NB. what should the db syntax be?

</ = person NB. use the below table for generating the form
>/person = p{Person created `person`}
NB. create a table (default type of column to text)
NB. ? for optional, lots of predefined types, including html types such as color, email, url, etc
NB. by default, data can only be submitted once all requirements are met
%person'name,birthday:day,color:color?,email:email,website:url'
NB. can tables be first-class objects? if yes, use comma (,) to separate the columns (spaces optional)
NB. types separated by colon (:), optional value denoted by question mark (?)
person = name, birthday:day, color:color?, email:email, website:url

NB. how should rows be inserted into a table
NB. use function syntax?
person{Hassan}{march 11}{blue}{hassan@gmail.com}{c3g.nfshost.com}
NB. alternate function syntax
a = person{Hassan;march 11;blue;hassan@gmail.com;c3g.nfshost.com}
b = person{Maria;january 8;red;maria@gmail.com;fb.nfshost.com}
a union b
NB. make types mandatory, then last value with type is last column
person = name:text, birthday:day, color:color?, email:email, website:url, Hassan, march 11, blue, hassan@gmail.com, c3g.nfshost.com
NB. nevermind, this style is preferred
person[args]{body}

NB. verify that function syntax and dom element body syntax is compatible

NB. what are the default datatypes in web-dsl?
NB. ints, nats, floats/doubles (use term used by J), strings

NB. autogen routes based on db tables
%personCRUD'name,birthday:day,color:color?,email:email,website:url'
NB. default to CRUD when tables are created
%person'name,birthday:day,color:color?,email:email,website:url'
NB. will create the following routes
>/create/person
</read/person
</readlist/person
>/update/person
>/delete/person

NB. Maybe values can be represented as an empty list that
NB. uses the * syntax to loop over; empty list expression being ignored
NB. without the *, the expression causes an error since it does not exist
html>head>title^body>*p{Your message was: $$}

NB. look to coffeescript for ideas on how the generated javascript should look like

NB. global styles (eg. below) affect everything, but component styles do not affect other components
@bgblue
h1{Hi}
foo = p@bgred{hi}
bar = p{hi}

NB. read ways to optimize the delivery and execution of web-dsl

NB. use domfragment to build dom tree, then insert all together into the full dom

NB. use event delegation to decrease the number of event listeners on the page
.foo>*.bar>p:c`log 'hi'`$$
NB. turns into
.foo:c`log baz`>*.bar>p.baz$$

NB. think about accessibility using the w3c docs wcag

NB. try to pre-render all javascript

NB. use < for parent operator since it is the opposite of child (>)

NB. automatically add image discriptions using ai

NB. have a relation/dom query operator
NB. relational query
person = name:text, birthday:day, color:color?, email:email, website:url, Hassan, march 11, blue, hassan@gmail.com, c3g.nfshost.com
NB. TODO
NB. dom query
a = .foo>.bar+.baz
NB. in a, find .baz and replace with .quux
a?.baz~.quux
NB. in a, find .baz's parent and replace with .quux
a = .foo>.bar+.baz
a?.baz<~.quux
NB. chaining modifications
a?.baz~.quux?.quux~.foo?.foo~.baz

NB. json query, retrive value c
obj = {
	a: {
		b: { 
			c: {}
		}
	}
}
obj?a?b?c
NB. or 
obj?a>b>c

NB. use regex for types or just create a type system?
nameorage = r`name|age`
nameorage = :name|age
/iam/$nameorage:nameorage = p{I am `$1:name`}+p{I am `$1:age` year(s) old}
NB. or use numbered case split
/iam/$nameorage:nameorage = p{I am `$1`}+p{I am `$2` year(s) old}


NB. nesting expressions
p{You can have i{italic} bold{bold} u{underlined} and span{spanned} text}

NB. create jwt tokens for authentication

NB. create plotting library using/similar to d3.js and the plot function in J

NB. other features that could be attempted
NB. all but first navigations should be instantaneous
NB. offline and progressive web app mode
NB. degrade gracefully when javascript is not available
NB. download only css/js that is required, then download rest in background

NB. use realworld example app to test web-dsl

NB. unused css and js removal and minification

NB. automatically generate sitemaps

NB. output should be semantic

NB. automatically generate swagger (api) description of the generated web app


NB. function syntax f(a)(b){c} paren for dom expr and brace for literal
NB. or allow domexprs as args in {}
foo = h1$$+p$$
foo{Hi}(span{hi})
foo = h1$$+$$
foo{Hi}(p>span{hi})

NB. keep web-dsl at a very high level, there should only be three parts NB. database layer, logic layer, presentation layer, 
NB. of which database, local storage, session storage, cookie, url params, ect are all in

NB. can GraphQL be done using a modified relational algebra?
NB. graphql
type Human {
  name: String
}
NB. web-dsl equivalent
human = name:s

NB. graphql
type Human {
  id: String
  name: String
  homePlanet: String
}
NB. web-dsl equivalent
human = id:s name:s homePlanet:s

NB. graphql
enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}
type Human {
  id: String
  name: String
  appearsIn: [Episode]
  homePlanet: String
}
NB. web-dsl equivalent
NB. `` before for constraints,
NB. in is defined as {{ (<x) e.~ cut y }}
human = `$3 in 'newhope empire jedi'` id:s name:s appearsIn:Ls homePlanet:s

NB. $num should use 0-indexed vars in currently defining rel

NB. how should escaping be done within ``? either `$ 1` (not `$1` which would refer to $1) to mean $1 in J or `\$1`
NB. the second works better if other things also need to be escaped
NB. I also hate the look of 'O''connell' => O'connell

NB. take another look at the Links and the ur/web programming languages
NB. also look at tablaM which is a relational programming language
NB. also look at sligh which converts essential logic into a full-stack web app and has a certifying source-to-source compiler

NB. use overloading to decrease the number of operators that are required (only do it if the op. and op: syntax can be completely removed from my lang?)
NB. 1 * 2 and student * teacher (relational join)

NB. forms can be automatically generated based on a relational expression
human = id:i name:s location:s
NB. would create a form with three inputs based on that schema

NB. having a haskell-like type system will help marshalling data and entering data into the system correctly (see above form generation)

NB. use type in url, then $num in the body
/foo/$i = `41 + $0`

NB. split code into front-end and backend automatically, see unison for distributed computations

NB. should sum types be added? it would add complexity and verboseness
NB. shouldn't it be possible to have a terse sum types?
:b = 0|1 NB. type of bool
/hungry/$b = ` +&3 \` *&12 $0 ` NB. use gerund ` and the first is used if the first construction is used; this is horrible

NB. what kind of effect system should this language use?

NB. all io functions should use the async functions, and be written the same way as normal J/Haskell

NB. add ranges to the type system
:w = 1..7

NB. how does K (kdb? q?) do relations?

NB. are maps just relations and/or should the syntax be similar?

NB. add wasm as a potential compilation target

NB. relational expressions are written in the rel lang, then converted into json if and when it is needed
NB. this would replace graphql (a query lang for json)
NB. graphql's many-to-many is problematic
NB. for example, join represent children in json, so a * b * c /= c * b * a because { data: a: { b: { c: {} } } } /= { data: c: { b: { a: {} } } }

NB. function types would be written like the following (if type inference fails or for documentation on function)
x:r NB. relation type
x:rr NB. rel -> rel; monadic func
x:rrr NB. rel -> rel -> rel;  dyadic func
x:srr NB. string -> rel -> rel
x:La NB. list of a (may be needed some times, but hopefully not, to keep it array oriented)
x:Lab NB. [a] -> b
NB. how would the list type be defined within the language

NB. api endpoints should just be considered global functions, and should be easily accessible through other functions
/foo/bar = .......
/foo/baz = /foo/bar
NB. the syntax of these is way too complicated, should it just use normal function names?
foo_bar NB. the _ could be used to delineate the parts
NB. but how would values be passed into the api? would I want to make it difficult or impossible (no leaky abstractions)?
NB. then this becomes easier
/foo/bar = .......
/foo/baz = ` 10 + foo_bar `

NB. values should be passed to the api endpoints as key-value pairs, perhaps like this `cut 'a 10 b 20'`
NB. there should be a way of accesssing these values

NB. the syntax that is created for this web language is starting to conflict with the J language
NB. perhaps the languages should start to diverge now?

NB. the whole language should be redesigned so that it goes from the abstract to slightly less
NB. based on what types of things are done using HTML+CSS+JS 
NB. see program refinements

NB. dyadic * can be used in the dom expr lang to account for empty arrays
NB. empty string and Nothing value are treated as emptiness as well
NB. equilvalent to `if (y == null || y.length == 0 || y == '' || y == Nothing) { x } else { c_1; foreach (e in y) { e }; c_2}`
(h1{Log in}+p{It seems you aren't logged in yet})*div>h1{Welcome Back!}+p$

NB. allow array left hand side for assignments
student teacher = sid sname * tid tname
NB. turns to
student = sid sname
teacher = tid tname
student_teacher_join = sid tid
studentTeacher = sid sname * tid tname
NB. or perhaps this makes more sense
studentTeacher = sid sname * tid tname
NB. turns to
student = sid sname
teacher = tid tname
student_teacher_join = sid tid
studentTeacher = sid sname * tid tname NB. as above!
NB. then 
student teacher = 10 20
NB. can be used to refer to pattern matching
NB. though the question remains if it should be haskell style (x:xs) or J style (length errors can occur)
NB. definitely J style (see below)

NB. the eval direction should be the same as J, ie. right to left
NB. even though dom exprs (div>p) might be written left to right, it can be thought of as wrapping everything to its right

NB. the UI should always show an indicator if an api call is taking too long processing in the background

NB. main features of graphql: single (data backend) endpoint, wraps both sql and nosql databases, data efficient

NB. what is the difference between symbols and variables in J

NB. should all api endpoints return html or html+rel?
NB. perhaps rel when called, and html+rel when viewed by the browser

NB. types are rank polymorphic using leading axis theory
NB. so [a] -> a => [[a]] -> [a]

NB. use the types to generate (selenium if required) test cases using property based testing (like quickcheck)
NB. somewhat similar to sligh, but this would allow for further changes of the transpiled/compiled program
NB. while ensuring components built with web-dsl would not break

NB. auto generate swagger docs

NB. use NB. for comments and NB: for docs, rather than the previous // and ///
NB. example for writing docs for the database
NB: $name lives at $location
person =: name location, 'hassan' 'pickering'
NB: $0 lives at $1
person =: name location, 'hassan' 'pickering'
NB: $ lives at $
person =: name location, 'hassan' 'pickering'

NB. allow nullable types within the rel lang by using haskell's maybe monad (for elegant chaining)

NB. all javascript features in the frontend should gracefully degrade when js is not available

NB. the types of names are allowed, pascal case, camel case, snake case
NB. actually use camel case all the time, but generate the url based on it if it is global
NB. fooBar =: ...... turns to /foo/bar api endpoint if it is a function
NB. fooBar =. ...... turns to fooBarV, fooBarE if it is a constant
NB. index.html turns to /index.html

NB. to have a complex syntax for values, require a space between values when they are of the complex syntactic type
+/i.10 NB. valid
+/ /foo NB. valid
+//foo NB. invalid, will be parsed as +// foo, whatever that means
+/ / NB. then this would mean the sum of the return value of the call to the root api endpoint?

NB. why does #a in {`#a`} mean events, while the syntax above allows for complex syntax for endpoints and that #a is clear that the var referenced is an id.
NB. since using just `a` makes it difficult to know where that var is coming from, and so there needs to be a a_id_ group (see nuvoc for name)
NB. perhaps using #a would be clearer, but it would also make it more verbose

NB. use session types to communicate between the client and server
NB. can this be automated, since the default should send data based on where that data originates
NB. for example, form data would go to the server, while api endpoints would send data to the client

NB. use haskell's types to give a simplified abstraction over REST apis
NB. for example, sending values of 'Maybe a' would decompose into 'a' if it is 'Just a' or give the proper 400s error code to the client
NB. see webmachine's decision tree for an example
NB. also take a look at servant

NB. allow definitions to be like this, to mean an unimplimented endpoint giving error code 500
/foo = _.
/foo NB. just by itself on a line will send an api request to /foo

NB. servant has authentication (see basic authentication on wikipedia)
/about NB. public
student@/courses NB. only student role permitted to access courses

NB. flesh out the details regarding roles, for example does it create relations in the db?

NB. add regex as a type; but should it be within strings or outside?

NB. what is the correct ratio of using things like regex as literals versus as strings?

NB. see links paper: Secure Compilation of a Multi-Tier Web Language
NB. from paper: A new class of multi-tier languages enables developers to mix client, server and database source code by shifting the burden of
NB. code and data partitioning to the compiler. LINKS is a strongly typed, multi-tier, functional programming language for the web
NB. (Cooper et al. 2006). From a single source file, the compiler gen- erates code for the different tiers of the web application: the back-
NB. end database, the web server and the client front-end, ensuring that all data is stored either on the client side or in the database.

NB. syntax for multiple arguments
mymacro{foo;bar} NB. ambigious, since the ; is part of a literal syntax
mymacro{foo`;`bar} NB. doesn't really mean anything
{foo}mymacro{bar} NB. perhaps the best option!

NB. am I just creating another Links, but with better syntax!?

NB. printing the output of any expression gets html-escaped, and all url-escaped (%20, etc) are decoded before being passed to the program
NB. p{<} => p{&lt;} and the same for code in inputs and from the user, it will never be evaled without being encoded to remove any potential meanings

NB. links
/foo = p{hi}
/bar = a[href=/foo]{Go to Foo}

NB. each channel created is typed and all data marshalling happens automatically

NB. channel syntax
createchannel cut 'client:d db:r'
'client' send p{hi}
'db' send student * teacher

NB. specifying relation types
db:r = sid sname * tid tname 
db:(i s i s) = sid sname * tid tname 
db = sid:i sname:s * tid:i tname:s          NB. the original turns out to be the shortest

NB. compare ur/web to web-dsl
table room : { Id : int, Title : string }
table message : { Room : int, When : time, Text : string }
room = id:i title:s
message = room:i when:t text:s

NB. apparently regular expression types are actually a thing! See Regular expression types for XML by Hosoyo et al.

NB. could web development be done with only J types, while adding concepts like session/linear types?

NB. have updatable views; how should this be done?
NB. it seems that functional dependencies (and integrity constraints) are required for having updatable views

NB. have typed and size indexed arrays
a:iA3 = 1 2 3 NB. valid
a:iA3 = 1 2   NB. invalid
a:(iA2-3) = 1 2   NB. valid
a:(iA2*3) = i. 2 3   NB. valid
a:A0-_ = 0$0 NB. valid
a:A0-_ = i. 10 NB. valid
a:A0-_ = i. 100000 NB. valid
a:A1-_ = 0$0 NB. invalid
a:A1-_ = 1 NB. valid
a:A1-_ = 1 2 3 4 5 NB. valid
a:A+ NB. same as a:A1-_
a:A? NB. same as a:A0-1

NB. use separate type for relations that are ordered or that are limited (first 10 results) https://github.com/agentm/project-m36/blob/master/docs/dataframes.markdown

NB. my concept of writing one program to be split and run everywhere is called tier-less programming
NB. and the concept of taking one session type and breaking it into multiple distributed computers that are inverses

NB. actually, types systems would probably get in the way of keeping the code concise
NB. the best way would be to annotate a few things, then have the compiler infer the rest (HM type inference), including potential optimizations (i32 vs i64)
NB. wasm doesn't even support small integer types, so perhaps there is a limit to what these optimizations can do

NB. could use bifunctor when using sum types
:foo = bar`baz NB. a foo is either a bar or a baz
a:foo NB. a has type of foo (is either a bar or a baz); should it be a:bar?
f a NB. apply f both when it is a bar and when it is a baz
*&2`+&3 a NB. apply *&2 if it is a bar, otherwise apply +&3 if it is a baz

NB. perhaps sum and product types can be modelled using the current J lang?
NB. let val_n and val_m be some data, where (type val_n) /= type val_m
NB. let sum => 
NB. 	left = val;a:
NB. 	right = a:;val
NB. let prod = val_n;val_m NB. disparate types require boxing
NB. based on the following reasoning:
NB. let a = a | null
NB. then a * b => 
NB. 	a * null => a
NB. 	null * b => b
NB. 	=> a | b

NB. hand-crafted version (lol)
NB: $ lives at $
NB. auto-generated version
NB. using the following example from chris date
NB. is_entity  ( SNO ) AND
NB. has_SNAME  ( SNO , SNAME ) AND
NB. has_STATUS ( SNO , STATUS ) AND
NB. has_CITY   ( SNO , CITY ) AND
NB. CITY = 'London'
NB: Entity $ has location $
person =: name location, 'hassan' 'pickering'
NB. in the following example all keys are considered part of the entity
NB: Entity $ and $, has course $
teaches =: #studentId #teacherId course, 'hassan' 'john' 'cs101'

NB. should there be special kinds of assignments?
NB. global vs local, mutable vs immutable (default), etc?

NB. allow the use of names rather than symbols for functions, ie. sum => +/

NB. rather than having ad-hoc polymorphism, perhaps rewriting NuVoc for web dev would be best?
NB. ie., student * teacher => student j. teacher, or perhaps student join teacher

NB. keep the languages as close to J as possible, for example the operator precedence
NB. eg. the @s in p@red{hi}+p@blue{hey} should be thought of as modifiers on the original dom element, to keep the operator precedence I want
NB. ie. p => p@red modifies the original dom element to also include some styling, similar to +/@:*/ and +/\
NB. the same should apply to keys in rel defs: student =: sid# sname such that the # suffix denotes that that col is a key (composite if used multiple times)
NB. ie. teaches:r =: studentId# teacherId# course

NB. what should something that modifies the same aspects of an element? eg. p@red@blue would this be red or blue? 
NB. most likely blue, though it could also be a warning/error only if it is applied directly to an element.
NB. allowed, since the blue and red are operating at different levels of specificity
@blue
p@red{hi}

NB. there are three ways of dealing with the relation problem, either nesting is implicit, nesting is explicit, or nesting is forbidden
NB. implicit
student join teachers
NB. explicit, where grouped is an adverb
student join grouped teachers
NB. though perhaps explicit should be this way, where j. is join and j: is grouped join
student j: teachers

NB. why do dom exprs have to have a parent element? can this be added automatically when needed?  p{hey}+p{hi} => div>p{hey}+p{hi}

NB. should dom exprs just be js code that is generated, or should they be considered a parsed string of type dom expr

NB. dom exprs should convert to normal html at compile-time

NB. look at how performant web app libraries are made, such as mithril, stage0, svelete, lit, mobx, and of course vanilla js

NB. nested sql example from leontrolski
SELECT NESTED { customer.name, customer.email, [ { product.id, product.cost, } ], sum(product.cost) AS total_cost, }
FROM customer LEFT OUTER JOIN NESTED product USING(customer_id) GROUP BY customer.customer_id
NB. my version (WIP)
'id' groupby 'total_cost =: +/cost' extend ('name email' p. customer) j: 'id cost' p. product
NB. perhaps columns could have an id (or hash) that is used to index into the column?


NB. mithril example
var root = document.body
var count = 0
var Hello = {
    view: function() {
        return m("main", [
            m("h1", {
                class: "title"
            }, "My first app"),
            m("button", {
                onclick: function() {count++}
            }, count + " clicks"),
        ])
    }
}
var Splash = {
    view: function() {
        return m("a", {
            href: "#!/hello"
        }, "Enter!")
    }
}
m.route(root, "/splash", {
    "/splash": Splash,
    "/hello": Hello,
})
NB. my style of creating complex html components
NB. should nullary functions (perhaps only for url functions) be allowed?
/hello = main>h1.title{My first app}+b#a{`#a` clicks}
/splash = a[href=/hello]{Enter!}
/splash''
NB. technically this would be preferred and simpler
/hello = main>h1.title{My first app}+b#a{`#a` clicks}
/ = a[href=/hello]{Enter!}

NB. an example of a web component; perhaps this can be used to create components that take multiple args?
<wc-arrow
	l=150 w=150 rot=20 filled=true>
</wc-arrow>  
NB. my style; still needs lots of work, for example what should be the default types (int/string), should boxed arrays be used, should rels be used 
wcarrow = div>p$+p$+p$+p$
/foo = wcarrow[150 150 20 1]

NB. the templating model needs to be updated with the nested relational model

NB. component in a dom expr should allow relations as an arg for the attrs

NB. name the attrs of the component for a one-off relation

NB. include fontawesome by default in web-dsl

NB. avoid web components since it uses (is it optional?) a shadow dom
NB. collisions (eg. in styling) can be avoided by giving ids to selectors ie #foo > ... 

NB. my style of creating complex html components; updated
wcarrow[s s s s] = dsv>p$+p$+p$+p$ NB. exactly 4 params where each is a string
NB. simplified (see url params for details); 4 goes later since it is a modifier; 
NB. length checks on arrays is probably going to be faster than on matrices; how should $ be referred within {``}?
wcarrow[s4] = div>p$+p$+p$+p$
/foo = wcarrow[150 150 20 1] NB. call syntax
wcarrow[i i s s] = div>p$+p$+p$+p$
/foo = wcarrow[150;150;'hi';'hello'] NB. boxed (heterogeneous) array, since types are different; unbox list by pattern matching
NB. boxed array with one nested array; ie a;b;c1 c2 => a;b;c1,.a;b;c2
wcarrow[i s] = div>p$+p$
/foo = wcarrow[(i. 3);'hey'] NB. converts to 0 1 2;'hey' => (0;'hey') , (1;'hey') ,: 2;'hey'
NB. boxed array with more than one nested array (cross product)
NB. relation as schema to args list; should the $ be the col names?
wcarrow[student] = div>p$+p$ NB. student was sid sname, ie. i s
NB. relation expression as schema to args list
wcarrow[studentTeacher] = div>p$+p$
NB. nested relation with one nested array (cross product)
NB. nested relation with more than one nested array (cross product)

NB. set global settings as either of these two ways
NB. a special comment at the top of the file
NB: foo=bar font=serif
NB. or as a global setting
@serif

NB. use system fonts by default rather than web fonts, unless explicitly specified

NB. dark mode should properly invert colors such that dark on bright becomes bright on dark

NB. @c for center x y, @cx for center x, @cy for center y, @c* for foreground colour

NB. attributes for html components must exist
foo[style=color:red] = .... NB. since style is a normal attr, it is not transformed, ie. style="color:red"; or should that be only on predefined elems?
foo[href=/hi] = .... NB. since href is allowed on all elements, it is not transformed (see htmx)
foo[data=1 2 3] = .... NB. data attr transforms to data-value
foo[bar=/hi] = .... NB. since bar is not a normal attr, it transforms to data-bar eqivalent in html 

NB. named attrs
foo[bar:i baz:i] = $bar + $baz
/hi = div>foo[bar=10 baz=20]
NB. array attrs (since it is an array oriented lang)
foo[data:i] = +/data
/hi = div>foo[data=i.3]
/hi = div>foo[i.3] NB. simplified

NB. https://latex.vercel.app/ for latex style (seems useful for J programmers)

p@cr NB. creates a p elem with red color; does this even make sense if it is not sent to the client? or should it be equivalent to / = p@cr, though forbidden?
p = p@cr NB. redefines p elem to always have the red color



NB. htmx
<!-- have a button POST a click via AJAX -->
<button hx-post="/clicked" hx-swap="outerHTML">
    Click Me
</button>
</ = b[post=/clicked]{Click Me}

NB. or should I just use the dom tree replacement operator (? was it) for it instead (assume it is for now)
>/clicked = p{You have been clicked!}
>/clicked = b?p{You have been clicked!} NB. should replacement only work either for current doc and/or previous doc?

NB. use htmx for this as well
/foo = h1{Hello World}+b:/bar{Click Here} NB. on default event (click) route to /bar
NB. can be changed to this, though it is slightly more verbose
/foo = h1{Hello World}+b[href=/bar]{Click Here} NB. on default event (click) route to /bar
/bar = h1{Hello, World!}+b[href=/foo]{Click Here again}

NB. pattern matching and function declaration
a =: ... NB. normal def of either var or func
a,b =: ... NB. assign b and then do a,b
(a,b) =: ... NB. compute a 2 (atom/array/matrix on leading axis), assigning the first to a and the second to b
(a;b) =: ... NB. same as above, though top level must be boxed, and types may be different
f a =: ... NB. compute, then assign to a, then compute f(a)
a f b =: ... NB. same as above, though binary/dyadic

NB. send and receive syntax
send / = ...
/ = send ...
NB. this would not be allowed
/ = send ...
/ = receive ... NB. / has already been defined
NB. chained
/ = receive ... send ...
/ = receive ... [ send ...

NB. add dead code elimination

NB. automatically add rel=preload (or preconnect if the resource is definitly needed) to all external links
NB. "Bear in mind that while <link rel="preconnect"> is pretty cheap, it can
NB. still take up valuable CPU time, particularly on secure connections. This is
NB. especially bad if the connection isn't used within 10 seconds, as the browser
NB. closes it, wasting all of that early connection work."
<link rel="preload">
<link rel="preconnect" href="https://example.com">

NB. incremental loading of js like qwik if it is faster than bundling all js together
NB. though perhaps inlining css/js for above-the-fold, then async the rest, but that will make caching more difficult

NB. send the evaled code to the client, along with how to update it if js is enabled
b#a{+1}+b#b{-1}+p{Total: `(#a)-#b`}
NB. turns to
<button id="a">+1</button>
<button id="b">-1</button>
<p>Total: <span id="val">0</span></p>
<script>
	document.querySelector('#a').addEventListener('click', () => {
		val = document.querySelector('#val')
		val.innerText = parseInt(val.innerText) + 1
	})
	document.querySelector('#b').addEventListener('click', () => {
		val = document.querySelector('#val')
		val.innerText = parseInt(val.innerText) - 1
	})
</script>

NB. use push-pull reactive programming (conal elliot and frp) to see how laziness can be implemented

NB. it seems laziness (assuming js-on-demand, given stable internet) can be implemented as the following (from qwik)
<div on:input="./path-to-input-handler.js">
	<input value="hello"> <!-- the value "hello" is computed from the component's data store
</div>
<script> <!-- basically the only js needed on app startup, which will then pull the required functionality from the server -->
	for (const event of events) {
		document.addEventListener(event, e => {
			const target = e.target.closest(`on:${event}`)
			if (target) {
				const jsPath = target.getAttribute(`[on\\:${event}\`)
				import(jsPath).then(mod => mod.default(e))
			}
		})
	}
</script>

NB. break both css and js into the following categories: core (used everywhere), above-the-fold, page specific (keep separate if only js can be cached)

NB. progressive web apps seem to be the best option compared to rehydratable/resumable web apps
NB. since sending data across the network is the slowest compared to doing the computation yourself
NB. to get the best results with pwa, js should be kept to a minimum
NB. the biggest issue with pwa will be reconciling between both the server and the client modifying the same parts of the db

NB. should my language use unary/binary rather than monadic and dyadic? It will most likely contain monads, so yes
NB. and should function and data

NB. J concepts that would be useful in a web programming language (mathematical concepts will be given lower importance compared to web-related concepts)
NB. the table below will be of the form verb/noun, unary/binary, function name in english (which can be used instead of the ascii symbol version) (or undefined), explaination/notes
= unary UNDEFINED
= binary equal eq
=. unary UNDEFINED
=. binary/copula is, perhaps used as im/mutable var, =. immutable should be easier to type, and =. is easier to type, but =: looks nicer (like :=), also name immutable as `is` and mutable as `mut` see =:
=: unary UNDEFINED
=: binary/copula mut 
< unary box
< binary lesser
<. unary floor
<. binary lesserOf
<: unary decrement
<: binary lesserOrEq, lesserOrEqual is too long of a name
> unary unbox, open doesn't show the connection between > and <
> binary greater
>. unary ceiling
>. binary greaterOf
>: unary increment
>: binary greaterOrEq
_ noun infinity inf, _ as a prefix to numbers is unchanged (so _1 is the way to write negative numbers)
__ noun negativeInfinity negInf
_. noun todo null "undefined"
_: unary/binary infinite, function which returns _
+ unary UNDEFINED
+ binary plus 
+. unary UNDEFINED
+. binary or gcd
+: unary double
+: binary notOr
* unary signum
* binary times
*. unary UNDEFINED
*. binary and lcm
*: unary square
*: binary notAnd
- unary negate neg
- binary minus
-. unary not
-. binary less notIn
-: unary halve half
-: binary match
% unary reciprocal
% binary divide div
%. unary matrixInverse matInv
%. binary matrixDivide matDiv
%: unary squareRoot
%: binary root
^ unary exponential
^ binary power
^. unary naturalLog natLog ln
^. binary logarithm log
^: conjunction do apply, ^:(_1) would be called undo
$ unary shape
$ binary reshape
$. unary UNDEFINED
$. binary UNDEFINED
$: unary/binary self
~ unary/adverb duplicate
~ binary/adverb flip swap
~. unary unique uniq nub
~. binary UNDEFINED
~: unary uniqueIndexes
~: binary notEqual notEq


. unary det determinant, the following can be used ..  .:, though only if other functions don't use it (for example F.:) (.. could be used in the repl to refer to the previous computation)
. binary matrixProduct, +/ . * this is apparently different to +/@:* or +/@*, at least when the shapes are different of x and y
{:: unary path, 
{:: binary leaf, 
{{ }}

|
|.
|:
:
:.
::
,
,.
,:
;
;.
;:
#
#.
#:
!
!.
!:
/
/.
/:
\
\.
\:
[
[.
[:
]
].
]:
{
{.
{:
}
}.
}:
"
".
":
`
`.
`:
@
@.
@:
&
&.
&:
?
?.
?:


a.
a:
A.
A:
b.
b:
B.
B:
c.
c:
C.
C:
d.
d:
D.
D:
e.
e:
E.
E:
f.
f:
F.
F:
g.
g:
G.
G:
h.
h:
H.
H:
i.
i:
I.
I:
j.
j:
J.
J:
k.
k:
K.
K:
l.
l:
L.
L:
m.
m:
M.
M:
n.
n:
N.
N:
o.
o:
O.
O:
p.
p:
P.
P:
q.
q:
Q.
Q:
r.
r:
R.
R:
s.
s:
S.
S:
t.
t:
T.
T:
u.
u:
U.
U:
v.
v:
V.
V:
w.
w:
W.
W:
x.
x:
X.
X:
y.
y:
Y.
Y:
z.
z:
Z.
Z:

NB.
NB:

assert.
break.
continue.
else.
elseif.
for.
for_ijk.
goto_lbl.
label_lbl.
if.
return.
select.
case.
fcase.
throw.
try.
catch.
catchd.
catcht.
while.
whilst.




NB. j. for joins seems good as well

NB. perhaps checkEq (defined later) could use ?: ("is?" "equal") since the : suffix is the suffix for equal

NB. things like *: (binary not-and) could be repurposed for joins, so that ad-hoc polymorphism would not be needed

NB. @: and @ should be swapped

NB. Type systems for array programming from Dex lang seem interesting

NB. look to haskell prelude and base functions for ideas
NB. J needs an unwords function perhaps this is the best in J?  ; 1 6 2 6 5 { (cut Today), < ' '
NB. nevermind, unwords =: ;:^:(_1)
NB. J also has taketo and dropto (similar to Haskell's takeWhile and dropWhile)

NB. allow modifiers on copula and function composition
NB. `is` and `is mut` as well as `@` and `@~`

NB. compile down to typescript, and if needed, compile the typescript down to js

NB. have the css part be declarative and highlevel (only things that are seen should be written)

NB. make operations available to the user only those that are both correct and efficient, such that all programs are correct and efficient
NB. similar to how k does things with efficiency; for example ban the use of pixels and instead use percents/ems/rems

NB. using css3 grid's col: 2 / 3; row: 2 / 3; is a lot more verbose than just using cells (at least for default) 
NB. by placing it at (1,1) (assuming 0-index), for example using the following syntax: .page@lx1y1

NB. do not use css reset, such as normalize.css, since all browsers render things slightly differently (especially when talking about support for everyone)
NB. instead, provide fallbacks if required

NB. prerequisites for statements in css should be automatically inferred based on their usage
NB. for example, div@g@lx1y1 (see above) can just be written as div@lx1y1

NB. if a certain functionality that is only provided through css grid in web-dsl is used (which would provide a nice dev experience)
NB. compile it down to the basic version, such as css grid turning into floats

NB. lazy load (qwik-style) things that are known to not be used by most people, such as share buttons on pages

NB. be able to figure out how to lay images responsively based on the surrounding html
NB. for example, a background image uses the cover feature (the default) (such as for hero images) then the overlapping text 
NB. on the left hand side would make it the un-focal point, leaving the part of the image on the right to become the focal point when resizing the page

NB. include dom exprs not only through html components, but also through "includes"
NB. though concepts like partials and variable (id renaming, etc) need to considered
foo = div>p{hi}
bar = foo+p{hey}

NB. should the way to define types be ::? this would make the distinctions clearer in code
i::i NB. a range has type i, but it could also mean i:: var i
foo::i NB. new way, foo has type int
NB. this would also mean that chaining colons together would not be allowed

NB. coercion example from one type to another; var references after @ are resolved first
foo = p@cred{hi}
bar = p@foo{hello} NB. use foo's styling to style this paragraph; also makes it clear what var is playing in this expression
baz = p@cblue{heyah} 
quux = foo+bar@baz+baz NB. bar is being further overidden with baz's styling

NB. how should fallback in css be done? should it be handled by the system or the user? for example
div@cblue@cred NB. should this be div { color: blue; color: red; } or { color: red; }?

NB. remove attrs by specifying them as false, not this disgusting way
NB. "To be clear, the values "true" and "false" are not allowed on boolean
NB. attributes. To represent a false value, the attribute has to be omitted
NB. altogether. This restriction clears up some common misunderstandings: With
NB. checked="false" for example, the element's checked attribute would be
NB. interpreted as true because the attribute is present."

NB. bidirectional type checking/subtyping seems interesting: https://www.haskellforall.com/2022/06/the-appeal-of-bidirectional-type.html
NB. this would allow me to add in refinement types and existential qualification while still getting type inferencing

NB. be able to do nested pattern matching
(a;(b c);d) =: ...
(a;(b;c);d) =: ...

NB. define values from among rgb[a], hsl[a], hwb. hwb is the best option, since it maps really well to carol tuttle's color system/theory, followed by hsl[a]
NB. as well, it makes getting lighter and darker colors of a particular color trivial, ie.
NB. \(h, w, b)
NB.		-> (0 120 240, w, b) with red (0), green (120), blue (240); choose colors between 0-360* for mixtures 
NB.		-> (h, w + 15, b) if you want a lighter color
NB.		-> (h, w - 15, b) if you want a less light color
NB.		-> (h, w, b + 15) if you want a darker color
NB.		-> (h, w, b - 15) if you want a darker color
NB.
NB. see https://en.wikipedia.org/wiki/HWB_color_model and especially https://drafts.csswg.org/css-color/#the-hwb-notation for more info
NB.
NB. (*technically, hwb is going to be added in the future, and is not currently available/only available on the newest browser versions, 
NB. though I can always compile down to the others (see csswg link above))
NB.
NB. syntax: hwb(hue whiteness blackness [/ alpha]) NB. optional alpha followed by / such as hwb(0 0 0 / 1) or hwb(0 0 0 / 100%)
NB. note, w + b <= 100 if w + b > 100 decrease both w and b proportionally until w + b <= 100
NB.
NB. perhaps something like this can be used as a simple rule of thumb (though it seems relative values of w and b are more important than specific values),
NB. hwb(x >20 <20) -> tint
NB. hwb(x >20 >20) -> tone
NB. hwb(x <20 >20) -> shade
NB. hwb(x <20 <20) -> hue
NB. see wiki diagram for better visualization
NB.
NB. use a rgb-hex-like value to quickly define hwb values
NB. 
NB. Short form: @c(0-I)(0-A)(0-A)[0-A]
NB. 0123456789ABCDEFGHI = 19 digits for h; goes up in increments of 19; 0 19 38 57 76 95 114 133 152 171 190 209 228 247 266 285 304 323 342 (next value not needed; 342 + 19 = 361 = 1 ~= 0)
NB. 0123456789A = 11 digits for w; goes up in increments of 11; 0 11 22 33 44 55 66 77 88 99 (does not include 100; should 99 be 100?)
NB. 0123456789A = 11 digits for b; goes up in increments of 11; 0 11 22 33 44 55 66 77 88 99 (does not include 100; should 99 be 100?)
NB. 0123456789A = 11 digits for a (optional); goes up in increments of 11; 0 11 22 33 44 55 66 77 88 99 (does not include 100; should 99 be 100?)
NB. 
NB. Long form: @c(2*(0-I))(2*(0-A))(2*(0-A))[2*(0-A)]
NB. 0123456789ABCDEFGHI = 19 digits for h; 19 * 19 = 361 => 360 mod 361 => 0-359 is useful, 360 (IH) and 361 (II) are redundant
NB. 0123456789A = 11 digits for w; 11 * 11 = 121 => 21 nums are redundant; perhaps w <. 100 would be good?
NB. 0123456789A = 11 digits for b; 11 * 11 = 121 => 21 nums are redundant
NB. 0123456789A = 11 digits for a (optional); 11 * 11 = 121 => 21 nums are redundant
NB. 
NB. examples (nums in degrees/percent)
NB. @c120 (light orange; 19 22 0) (hwb short form)
NB. @c1205 (light orange, half transparent) (hwba short form)
NB. @c9C1814 (peacock blue; 183 19 15) (hwb long form); 183 (9C) = 9 (9) * 19 (digits) + 12 (C); 19 (18) = 1 (1) * 11 (digits) + 8 (8); 15 (14) = 1 (1) * 11 (digits) + 4 (4)
NB. @c9C181450 (peacock blue, half transparent) (hwb long form)
NB. 
NB. color mixing (see above for more):
NB. short form (add and subtract from current color): @C[_](0-I)[_](0-A)[_](0-A)[[_](0-A)]; eg. @C_200 (subtract 38 hue); @C020 (brighten by 22); @C022 (change to tone)
NB. long form  (add and subtract from current color): @C[_](0-I*2)[_](0-A*2)[_](0-A*2)[[_](0-A*2)]; eg. @C_200000; @C00
NB. @C_20_00_00 (max chars 11 to define color mixing)
NB. 
NB. max char lengths for different options
NB. @c000 hwb short
NB. @c0000 hwba short
NB. @c000000 hwb long
NB. @C_0_0_0 hwb mix short
NB. @c00000000 hwba long
NB. @C_0_0_0_0 hwba mix short
NB. @C_00_00_00 hwb mix long
NB. @C_00_00_00_00 hwba mix long

NB. the name webdsl (not web-dsl) has already been taken (https://github.com/webdsl/webdsl)
NB. still need to find a good name for my program, perhaps ihsaan?

NB. setting margin on x axis shorthand transforms
margin-left: auto;
margin-right: auto;
NB. can be simplified to 
margin-inline: auto; NB. where inline means x dimension, and block means y dimension

NB. remember that @c @cx and @cy have been moved to @ac @acx and @acy

NB. named colors
NB. @cx where x is one letter (uppercase or lowercase) which is a shorthand for the names of colors
NB. the first letter of the color's name is used, ie. red => @cr
NB. perhaps some of these colors that are color theory/type specific should be removed?
NB. starred names are those of the primary/secondary/tertiary colors (see link: https://en.wikipedia.org/wiki/HWB_color_model); underscores are incomplete
NB. color names taken from https://louisem.com/29880/color-thesaurus-infographic and https://www.colorhexa.com/color-names
NB. *** aqua (cyan blue)
NB. *** blue
NB. *** cyan
NB. daffodil
NB. eggshell
NB. *** fuchsia (magenta red)
NB. *** green
NB. hazelnut
NB. ivory
NB. jade
NB. khaki
NB. *** lime
NB. *** magenta
NB. navy
NB. *** orange
NB. *** purple
NB. q_________________________________
NB. *** red
NB. scarlet
NB. *** turquoise
NB. ultramarine
NB. violet
NB. walnut
NB. xanadu
NB. *** yellow
NB. z_________________________________
NB. Ash
NB. Black
NB. Chartreuse
NB. Denim
NB. Eggshell
NB. Fire
NB. Gray
NB. Honey
NB. Ice
NB. Juniper
NB. K________________________________
NB. Lavender
NB. Mauve
NB. Nickel
NB. Onyx
NB. Pink
NB. Q________________________________
NB. Rose
NB. Silver
NB. Tan
NB. U________________________________
NB. Vermillion
NB. White
NB. X________________________________
NB. Yam
NB. Z________________________________

NB. actually, use one letter for the color, then one letter can be used as a color suffix modifier to lighten/darken, etc.
NB. @cb[h w b g H W B G] though it seems this model is waaay too lacking in terms of data contained in it (vs color long form above)
NB. H W B G refer to the more extreme versions of their lowercase counterparts
NB. perhaps limiting the color range to the color type of the website would help? ie. type 4 web pages would only use hues for the base colors, and a little w b or g if needed

NB. use assemblyscript as the compilation target for my language, which is basically typescript with wasm types
NB. https://www.assemblyscript.org/ https://www.assemblyscript.org/introduction.html
NB. use https://github.com/lume/asdom to do dom manipulations, such that a dom expr turns to compile-time operations using web apis understood by asdom compiled to wasm
NB. actually, apparently dom counts as IO and wasm may be pretty slow at doing things like that (wasm is better at computation); perhaps assemblyscript isn't that great of a compilation target?

NB. background color can be set with @b followed by a color (name, hwb[a] (long|short))

NB. automatically modify the program based on accepted standards. for example, p@cy{hi} would turn to p@cy@bb{hi} so that the text has the proper contrasts (based on wcag web accessibility guidelines)

NB. centering done through logical properties
NB. margin-{block,inline}-{start,end}
NB. padding-{block,inline}-{start,end}
NB. border-{block,inline}-{start,end}-{width,style,color}

NB. dark mode is automatically derived, though it can be set using this syntax: @d followed by a color. @d alone will enable dark mode for that component, which can also be done for the website
NB. @i can be used to invert the colorscheme (dark -> light; light -> dark) of a component
NB. the colorscheme that is used is automatically determined based on the users preference

NB. the outputted css should be grouped by type, with values that can conflict in the order that they appear in the file (so that the meaning remains),
NB. see https://css-tricks.com/poll-results-how-do-you-order-your-css-properties/
NB. for example p@cr@cb@g{hi} => p { display: grid; color: red; color: blue; }

NB. perhaps values that replace and values that override are different things, for example p@cr@cb => p@cb versus p@displayblock@displaygrid?
NB. actually, replacable values should not be allowed, and, if needed, all fallbacks are provided by the compiler

NB. actually, leave out session types, and use the compiler to be able to generate simple html/css/js or pwa-style html/css/js

NB. allow type variables (generics) in the type level

NB. look up what html+css+js do wrong so that they can be fixed in my lang

NB. see what BQN (and k) does that I could take from

NB. support unicode functions for all base functions (named functions in z locale do not have to be included) (see my previous project about concealing unicode characters)
NB. example of a user defined function in unicode; only one unicode character can be used for the name, terminating the function (similar to i. which allows no-space chaining, ie. p:i.)
NB. the generated code would use a nickname for the unicode code point used, otherwise just something like u29374.
‚ãà =: join

NB. see the color naming system for ideas on how color modifiers should work
NB. 'What do you imagine ‚Äúvivid deep blue,‚Äù ‚Äúvery dark green,‚Äù or ‚Äúpale light reddish-orange‚Äù to look like? These are examples from the Color Naming System
NB. (CNS) described by Toby Berk and coauthors in a 1982 paper published by IEEE Computer Graphics and Applications, which I proposed CSS adopt in 1996.'
NB. 'Using two base-colors evenly mixes them; using a splash color mixes them unevenly, with the base color dominating. So, there's a smooth transition from
NB. red => orangish red => orange red / red orange => reddish orange => orange.'
NB. 
NB. BNF of CNS from https://en.wikipedia.org/wiki/Color_Naming_System
NB. named-color      := achromatic-color | chromatic-color
NB. 
NB. achromatic-color := 'black' | 'white' | lightness gray
NB. gray             := 'gray' | 'grey'
NB. 
NB. chromatic-color  := [ tint | shade ] hue | [ lightness | saturation ]? hue
NB. tint             := 'whitish' | 'pale' | 'rilliant' | 'vivid'
NB. shade            := 'blackish' | 'dim' | 'deep' | 'vivid'
NB. saturation       := 'grayish' | 'moderate' | 'strong' | 'vivid'
NB. lightness        := 'moderate' | 'very'? [ 'dark' | 'light' ]
NB. hue              := splash-color? base-color | base-color '-' base-color
NB. base-color       := 'red' | 'orange' | 'brown' | 'yellow' | 'green' | 'blue' | 'purple'
NB. splash-color     := 'reddish' | 'orangish' | 'brownish' | 'yellowish' | 'greenish' | 'bluish' | 'purplish'

NB. css lab and lch color models and functions seem quite interesting as well, perhaps hwb can be replaced by this?

NB. issues with css that should be fixed in my lang:
NB. float for designing layouts, font definitions without quotes on the names, display property (replace with logical properties?), too complex and hard to remember (especially layout),
NB. cascading styles that affect code you don't want affected*, no edge cases, no errors, should be as high-level as possible, flexbox and grid complicated including properties,
NB. media queries (instead use responsive units, eg. em rem vh vw), poor defaults, too many properties and attributes, use of preprocessors (showing that the base lang is lacking),
NB. lack of modularity (see cascading), lack of variables**, see preprocessors to learn how to make css better, flex should be a subcase of grid, html+css should be contained in js,
NB. metaclasses should exist (a class that is a list of other classes), preprocessors add extra compilation step, default styling doesn't look good, aligning items is difficult,
NB. alignment properties in flexbox should be writing-mode relative
NB. see https://wiki.csswg.org/ideas/mistakes for more technical issues
NB. * this can be solved by containing css within an expression to prevent it from affecting others, with reuse as the following: (see https://www.xanthir.com/b4o00 for potential problems)
foo =: div>p{hi}+p{hello} [ p =: p@cr NB. this will color both p's red, do this at the top-level of the program to affect it in all files
foo =: div>p{hi}+p{hello}+p@cb{hey} [ p =: p@cr NB. overriding the last p's color to blue; p@cb{hey} => (p@cr)@cb{hey} => p@cb{hey}
NB. ** can be done like this
bar =: p@foo{hi} [ foo =: @cr@by NB. see link to * above; all uses of @foo have to be checked at usage site for correctness (ie. properties exist for that element, otherwise error/drop prop)

NB. see how haskell does web page layout

NB. how to do animations using the @ syntax?

NB. see how typescript with jsx (tsx) would fit into a cohesive language

NB. wasp lang seems similar to what I want to do as well, though with a declarative part that hooks into react+js (though react is a bad idea, svelte style is prob best) https://wasp-lang.dev/

NB. should symbols (J term) be used for projecting a column? 

NB. should x and y axis be replaced by length and width (or something else) (logical properties means things may be reversed/flipped)?
NB. it should be kept the same, but the application would be flipped along the y axis for rtl langs

NB. use css grid by default (even when 1xn or nx1 matrices), and if some feature is only available on flexbox, then use that
@g4x1 NB. can potentially become flex

NB. there are three types of modifications on a 2d plane: scale, rotate, reflection, translation (align)
NB. the list of placement modifiers @ align ({top,center,bottom} {left,center,right} | fill | baseline)
@ac
@af 
@ab NB. aligns to the base of letters, not to the bottom
@atl
@atc
@atr
@acl
@acc
@acr
@abl
@abc
@abr

NB. use the repeat minmax auto-fit syntax for all grids, ie. display: grid; grid-template-columns: repeat(auto-fit minmax(200px, 1fr)); 
NB. auto-fit can be replaced with auto-fill (see docs for more info)
NB. example in my lang (size 200px to 1fr)
@g@s200pxt1fr
NB. which should simplify to (from 200px)
@g@f200px
NB. since 1fr is the default max
@g@gg1em

NB. examples
@p2rem NB. padding 2 rem
@m1rem  NB. margin 1 rem
@sl500px NB. (size large is 500px; max-width: 500px)
@atc NB. align top center

NB. perhaps fr units should be the default units for grid cell sizes

NB. should box-sizing: border-box; always be enabled?

NB. only use rem in my lang, since em will change sizes based on where it is pasted in (ie. it cannot be used in the html components and behave the same)
NB. or perhaps (the default?) use rems for each html component, and then use ems for any styling that is related to that component (devtips recommends this)
NB. or perhaps there should be a scaling modifier?
NB. em unit is relative to parent, rem unit is relative to the root element

NB. since all functions are of the type :a :a->b :a->b->c, perhaps having the op between each char a function type would be useless,
NB. instead save that for something else. use a destructor-like syntax to define the types that a function takes.
NB. must be of the form x functionName y, with optional typing on either/both, with the type of f inferred (ie. f:isb)
(x:i f y:s) =: x;y
NB. perhaps use juxtaposition for wrappers, such that abc => a(b(c)) where a and b are wrapper types like List or Maybe, prefixed by effects (see koka)
(x:i f:Ri y:i) =: x ? y NB. :Ri means that it is a random (list of) integers
NB. as well, allow types to be defined in the same style
(x:i :V y) =: :iV:y NB. a length-indexed vector is a type-level nat with an arbitrary type for y 

NB. use \ for escaping in strings, ie. 'my name is \'hassan\''

@a align (the whole grid, ie. @abr@g; called justify-content(hor) and align-content(ver))
@g grid
@ga grid align (align all items in the grid; called justify-items(horizontally) and align-items(vertically) in css; place-items shorthand may be helpful)
@gc grid columns
@gr grid rows
@gg grid gaps
@ggr grid gap rows
@ggc grid gap columns
@s span
@s2x3 (grid item takes up 2 rows, 3 columns)

NB. should I use a layout algorithm for css such as the cassowary layout algorithm (grid style sheets), or something similar? Cassowary is awesome!
NB. cassowary algorithm (and ccss) is like logic programming (prolog/relational calculus style), the paper introduces inheritance, perhaps I can leave that out?
NB. perhaps I can use (something similar to?) constraints that compile down to css3? in which case the most important functions will be min, max, minmax, clamp, and probably variables
NB. another way may be to use a constraint solving language (like ccss or gss) then using a language like prolog/minikanren to compile that down to simple css.
NB. if I go down this route, I should allow the logic programming aspect of the language to be usable by the end user

NB. https://github.com/wasp-lang/wasp/tree/main/examples/realworld contains thoughts on web dev that I could use to improve my lang

NB. use haskell as the language for the parser and compiler, since many langs are written in it (at least from the academic crowd), and it could even compile down to WAT if needed

NB. the language should allow for an array of html exprs

NB. perhaps using unicode for user-defined functions might be a problem, since then user-defined functions would look different to the built-in ones
NB. although, J already does this as well, ie. i. vs foo, see growing a language by guy steele https://www.youtube.com/watch?v=_ahvzDzKdB0
NB. another option would be to do the following: ‚ãà =: join =: .... which would define both variants, though the issue still holds for the char. styles, which I would not want the
NB. users to be able to overwrite, perhaps this issue cannot be fixed?

NB. see http://seriouspony.com/blog/2013/7/24/your-app-makes-me-fat for issues related to cognitive drain regarding choices, such as with configuration files
NB. "If your UX asks the user to make choices, for example, even if those choices are both clear and useful, the act of deciding is a cognitive drain. And not
NB. just while they‚Äôre deciding. ‚Ä¶ Even after we choose, an unconscious cognitive background thread is slowly consuming/leaking resources, ‚ÄúWas that the right
NB. choice?‚Äù ‚Ä¶ If our work drains a user‚Äôs cognitive resources, what does he lose?  What else could he have done with those scarce, precious, easily-depleted
NB. resources? Maybe he‚Äôs trying to stick with that diet. Or practice guitar. Or play with his kids."

NB. have an online version of my lang so that people can try it out without having to install anything

NB. the /r/programminglanguages subreddit is great for ideas and learning

NB. use the Ohm editor (https://ohmjs.org/editor/#) to create a basic version of the grammar for testing purposes

NB. remember to take a look at Elm for some ideas as well

NB. perhaps having the eject on each compilation would be problematic, such as variable naming, program structuring, and library selection.
NB. instead, having the language build everything to a build folder may be the best, while I get started

NB. should I use (A|E)BNF or should I use PEG grammars?

NB. the following works for basic definitions, though probably will need to be exended to allow for modifiers
(x:i f y:s) =: x;y
NB. for example:
(x f u y) =: ... NB. would be used for something like 10 20 30 +/ 10 20 30 

NB. css does have the scale function, so perhaps the em and rem debate becomes irrelevant? ie. foo@sp1.2 (or perhaps foo@sp120)  (scale padding by 1.2x)
NB. @t for translate, @r for rotate, and @s for scale
NB. perhaps a non-linear system like the one that is used in tailwind may be useful for constraining values from 0x .. 25x
NB. no, I think I should stay with a linear system for now
NB. y = x/10
0 0
1 0.1
2 0.2
3 0.3
4 0.4
5 0.5
6 0.6
7 0.7
8 0.8
9 0.9
10 1
13
...
99 10

NB. hover states should be added to each thing that is actionable, by moving the color to the opposite of the background color
NB. ie. a blue link would turn dark blue on a light background, when hovered, but on a dark background would turn light blue

NB. disabled buttons would be the original color (h), though it will be an achromatic dark gray (w=40,b=60; approx)

NB. using logic programming with constraints on dom element placement seems like a very good idea
left NB. to the left of the leftmost of element y
right NB. "  right " rightmost "
top
bottom
x NB. both elements will be on the same x axis
y NB. " y axis
leftx NB. on the x axis and on the left
rightx
topy
bottomy
topleft
topright
bottomleft
bottomright
around
inside

NB. when doing logic/constraint programming = should be called implies or is, though prolog uses :- but I could just use -: right?
NB. also, dcg notation in prolog is quite beautiful, and that should be preferred (is it higher order functions for logic programming?)
NB. and dcg could also be combined into a peg grammar / (E|A)BNF grammar for creating langs within my lang
NB. A basic example of DCGs helps to illustrate what they are and what they look like.
NB.  sentence --> noun_phrase, verb_phrase.
NB.  noun_phrase --> det, noun.
NB.  verb_phrase --> verb, noun_phrase.
NB.  det --> [the].
NB.  det --> [a].
NB.  noun --> [cat].
NB.  noun --> [bat].
NB.  verb --> [eats].

NB. compare web development languages and gui frameworks that are used in prolog; as well learn prolog

NB. apparently you can have constraint programming without logic programming (see Oz lang as example)

NB. most likely, css grid can be emulated using linear constraint programming, and non-linear is not required

NB. don't use peg grammar (meaning is first match in grammar), since it conflicts with the usual haskell definition of parser combinators (meaning is list of all possible meanings)

NB. use logic programming along with refinement types to make my quickcheck property-based checking functions (the unicode should be the <-> symbol)

NB. refinement types
:n = :(i>=0) NB. a natural number is all of the integers greater or equal to zero

NB. use webp for images

NB. if logic programming is used, surely relational calculus should also be supported, right?

NB. having something like hoogle (and aplcart.info) for my language would be nice (and programs like these should be considered along with the language itself)

NB. have a single book that explains the whole language from beginner to advanced user

NB. this result seems really counter intuitive. it seems like incorrect error propagation.
NB. perhaps this can be formalized using haskell (using Either, Maybe, exceptions?)? 
   (+/%#) 0
0
   (+/%#) 0$0
0
   (+/√∑‚â¢) 1
1
   (+/√∑‚â¢) ‚ç¨
1
NB. haskell version, which is a lot more sane
average xs = if length xs == 0
							then Nothing
							else Just $ sum xs `div` length xs
Prelude Text.Parsec> (Just [1,2,3]) >>= average
Just 2
Prelude Text.Parsec> (Just []) >>= average
Nothing
Prelude Text.Parsec> (Nothing) >>= average
Nothing
NB. note that <./ 0$0 => _ and >./ 0$0 => __ is correct
NB. perhaps error propagation can be done using exceptions, such that if expressions can be removed
NB. note that this may imply the removal of certain elements (like a filter) which would cause issueswith the dimensions of data (if static shapes of data is used) (unless a NAN is used)
NB. perhaps $. can be used for haskell's monadic bind? (looking like haskell $ function application) (though it will conflict with $ for shape and $: self) (or perhaps it should be automatic? then function application would be done in a monad, or if none makes sense, the identity monad could be used)

NB. trees should be implemented using arrays, similar to how Aaron Hsu has done it in his compiler, though with the usage style of haskell for defining and manipulating them

NB. probably switch #. (from base 2) and #: (to base 2) since generally you go from "to base 2" then "from base 2"; though think carefully before doing it

NB. if using parsec, a basic file-reading parser is available from https://github.com/JakeWheat/intro_to_parsing/blob/master/ParseFile.lhs

NB. use the language server protocol (lsp) for editor integration for the language (basically all programming text editors support it: (neo)vim, emacs, atom, sublime, vs code, eclipse, visual studio)

NB. reason for using dependant types: "Dependent types are actually simpler from a programming language design standpoint. For example, you get generics for free, whereas otherwise you'd have to build that as a whole separate feature. And you don't need to invent a whole separate syntax for types vs. terms‚Äîwith dependent types, you can just unify them into a single term language. Also, I have to say, I love having the ability to prove arbitrary theorems that I'm interested in within my program. That alone is a killer feature."

NB. perhaps dependant types with my language could be used for optimization, correctness, etc. This would be helpful in converting the small set of primitives in J to their dependantly typed versions, which would allow for combining them in easy ways. See idris2 and agda for an example

NB. if using dependant types, use variables that start with a capital for types

NB. use '...' for previous expression when in the repl

NB. add holes in the language like haskells _ or _a on the rhs of an equation

NB. write the expressions typed in the repl into a file using a single command

NB. how does reactive programming work with an immutable language?

NB. perhaps the name for the language should end in script? (javascript, purescript, coffeescript, etc.)

NB. how should database migrations work?

NB.	saving a value to local storage should be as simple as adding D: before the expression (or D. if you want to save to a db).
NB. for example: 
button#b{Click me!}+p{You clicked the button `D: #b` times!}

NB. see https://github.com/ollef/sixten for how to do unboxed types and low-level optimizations

NB. see https://mercurylang.org/ for how to do a logical/functional programming language

NB. have a type-level language similar to the value-level language, perhaps something like a tacit/invisible-modifier language
NB. perhaps types could be thought of as sets and then manipulations, such as refinements, would be the restrictions on the sets
NB. how should refinements be written
i@:>&0@:<&10
i 0 10 NB. where restrictions are function arugments
NB. although function application is more like functors/monads, ie. Monad : * -> *, and Monad Int : *

NB. use <-> (checkEq) for quickcheck, and use -: (or perhaps =) for provable equality

NB. perhaps using css isolation in blazor would be useful in creating html components
h1@cb{hi} ==> h1[component2358032]@cb{hi} NB. where component2358032 is an html attribute used to constrain the application of the css

NB. take a look at hyperscript https://hyperscript.org/

NB. embedding scripts as dynamically generated attributes of the html tag
b#a@`('.text-xl';'.text-lg'){~ 2|#a`{Toggle the class="text-xl" on me on click}

NB. use typed inputs, rather than a new name for each input of a different type, 
ii NB. previous style
i:i NB. current style

NB. pattern matching should be extended to the more unusual cases
(a) =: i. 10 NB. top-level of the shape must be 1, otherwise it will give an error
() =: smoutput 'goodbye' [ smoutput 'hello' NB. composed using haskell's monads (IO ()), and run, with an empty array as the result

NB. perhaps recursive functions could be written like this?
NB. recurse decreasing y until left functions's base case (mempty value for the monoid) is reached, accumulating values by the left function
factorial =: 1: ` (* $:@<:) @. * NB. check sign (*) use this value as index into functions 1:`(*$:@<:) if 0 then 1: 0 else n * factorial (n-1) 
*$:<:

NB. this code prints 'hi' then 'bye' then index error (for some reason), even though the higher order functions should not be run during the first parse.
(smoutput 'hi')`(smoutput 'bye') @. 0

NB. darklang.com seems like a really cool lang. it is a simplified language for building backend servers, as well as interfacing with other apis

NB. by the way if expressions are written in the following manner (I FINALLY UNDERSTAND IT!!!):
function_case_0 ` function_case_1 @. expression_which_evaluates_to_an_index
NB. in haskell-like syntax
case expression_which_evaluates_to_an_index {
	0 -> function_case_0
	1 -> function_case_1
}

NB. arrays should be allowed to contain functions
funcs =: (f,g,h) NB. three function array

NB. equality or checkEq should choose the best implementation based on the size/type of the array
f <-> g NB. prove that f and g have the same functionality for the same inputs, and then allow the compiler to sub one for the other, based on the most efficient

NB. application of a gerund (array of functions) should apply as an applicative, ie. f`g 1 2 ==> (f 1), g 2
((2&*)`(5&+)) 1 2

NB. focus on tree rather than specific web related details
dom as tree
homogeneous trees using aaron hsu tree
manipulate using J
tree = (depthVector, data)
implicit map will be on data (second argument of tuple, like in haskell)
functions in general will either apply to the structure (ie. reverse) or data (and if tree is the data, it is mapped across)
Tree a -> (a->b) ==> Tree b
use ` for trees (gerunds are written as functions around "," for example, (+,-) will create an applicative)
, ,. and ,: things that are similar versions for trees ` `. `:
name of language should then be FPL for Functor Programming Language
perhaps I should go back to using string parsing? but what about urls, etc
I think I prefer unicode characters more than ascii, at least for writing and thinking
generalize the common operations used in apl such as +/ to use concepts like fold, monoid, mempty, and mappend 

NB. perhaps (+/%#) 0$0 ==> 0 since +/ 0$0 ==> 0 and # 0$0 ==> 0 so 0%0 ==> 0, which is correct

NB. could the unicode symbols be written as multiple ascii characters, with ligatures used to get symbols? no, this is a bad idea

NB. info that could be used for correctness/low-level-optimization: type, size, shape

NB. info for arrays should be based on each rank of the array (ie. is the array sorted on the outer rank or inner rank? ex. sorted boxed strings vs boxed sorted strings)

NB. having statistics for arrays should also be used for optimization

NB. perhaps the symbol for reverse could be , super imposed by ~ to mean reverse concatenate, and applied to y would yield the reverse of y

NB. interesting idea: program ==> logical description (based on its mapping) ==> logically equivalent programs ==> ideal program (based on types and info of array)

NB. perhaps the notation (f x) =: y ==> x =: f^:_1 y so that it generalizes pattern-matching to unification (with no changes to the syntax required)
NB. though they have this issue: https://stackoverflow.com/questions/3748592/what-are-nk-patterns-and-why-are-they-banned-from-haskell-2010?noredirect=1&lq=1
NB. which seems to only affect haskell-style definitions (which are not used in apl-like langs)

NB. murcury (prolog + haskell) seems interesting

NB. everything is a monad, then function composition becomes Kleisli composition

NB. literate web-dsl files should be allowed by the compiler (good for writing the book/docs)

NB. how should frp and its semantics be applied, for example, how would streams be represented and manipulated
a:Si =. 0 NB. a is a stream of ints, with the initial value 0
NB. user clicks a button which increments the current value of a, outputting a stream that includes the previous values
a =. (1 + 0 { a) , a NB. a ==> 1 0
NB. and the user clicks again
a =. (1 + 0 { a) , a NB. a ==> 2 1 0
NB. streams can be summed with the correct parenthisization if the new values are consed to the front of the stream
+/ a ==> +/ 2 1 0 ==> 2 + (1 + (0)) NB. which is the usual way summation is parened
NB. these expressions could probably store the previous result and reuse it to generate the next value, ie. (1 + (0)) would be the cached previous value

NB. how would reactive expressions that rely on things like time be updated and made efficient?


NB. how to create the source-transform-sink (publish/subscribe (?)) using basic js techniques, and how to make it efficient?
globalObject = {
	tick: () => $('#time').innerHTML(clock())
}
window.setInterval(1000, globalObject['tick'])
<p id="time"></p>

NB. 60s could be the default screen refresh rate, though window.requestAnimationFrame() and DOMHighResTimeStamp could be useful

NB. (reflex) frp code
p{The time is now `time`} NB. the time is the dynamic time signal
p{One plus one is `1 + 1`} NB. the expression 1+1 is transformed to (constSignal 1) + constSignal 1 ==> constSignal 2
circle mouse , 10 NB. create a circle at x and y of mouse, with radius 10
circle mouse , 10 %~ audioLevel NB. create a circle at x and y of mouse, with the size relative to the audioLevel
NB. frp reflex by ryan trinkle
NB. note that dom elements are created from the innermost of the expression outwards
dynamicText textArea NB. create a textArea which feeds its value to a dynamic text that is placed below it
NB. would generate the equivalent Haskell
textArea >>= \x -> dynamicText x
NB. or
dynamicText <=< textArea 
dynamicText textArea[maxlength=140] NB. create a textArea with a maxlength attr which feeds its value to a dynamic text that is placed below it
' characters',~ ": # textArea NB. create a textArea that displays the number of characters after it (toString is ":)

NB. use tacit programming as a way of representing trees (conflicts with modifiers, ie. f"(1) 1 2 3 may be fine, but what about f"(1 2) 1 2 3)
data BinaryTree a = BinaryTree a (BinaryTree a) (BinaryTree a)
									| Leaf
x = (BinaryTree 2 (BinaryTree 1 Leaf Leaf) (BinaryTree 3 Leaf Leaf)

NB. allow monadic values/functions to be combined using tacit programming
(foo bar)
NB. will become (assuming unary application)
do a <- bar y
   b <- y foo a
	 pure b
NB. will become (assuming binary application)
do a <- bar y
   b <- x foo a
	 pure b

NB. perhaps the + in p{hi}+p{world} should be extended to horizontally placed elems with - and | for vertically placed elems (probably + would be kept if the default is good; divs are blocks, ps are inline)

NB. the modifier !. can be used to supply the default value (ie. it would be like the fromJust in haskell)

NB. having a book that goes through the transition between named ==> ascii symbol ==> unicode symbol (optional) would be helpful
NB. since people think that the ascii is too difficult, as well, I want people to make web apps as simply as possible,
NB. and haskell is more readable for the beginner (https://documentation.divio.com/)

NB. most, if not all, dom elem constraints should be available through the use of ascii symbols rather than explicit grids, ie.
NB. in order of appearance: + sibling (default placement of block or inline), | vertical, - horizontal, ~ grid sibling (is this needed?)
div>p{a}+p{b}|p{c}-p{d}~p{e}

NB. creating tacit expressions should always be explicitly denoted. perhaps making it more regular with parens would be better
fooTacit =: (-:|.)
fooExplicit =: y-:|.y
NB. another option would be to use the assignment as tacit vs explicit, though the problem being that I may want to use =. and =: to mean something else, seems like a good option
fooTacit =. -:|.
fooExplicit =: y-:|.y
NB. if I wanted to differentiate between unary vs binary functions I could do the following
fooTacitUnary  =.. -:|.
fooTacitBinary =.: -:|.
NB. and of course, the variables used in the explicit version is able to determine if a unary/binary/ambivilant is being created, by looking at the vars used (x, y, etc.)
fooExplicit =: y-:|.y

NB. automatically convert explicit to tacit when compiling

NB. perhaps divs could be represented by parenthesis?
(p{hi}+p{hello}) ==> div>p{hi}+p{hello}

NB. how should styling be done when arbitrary CSS needs to be written?
foo[background=red]
NB. or perhaps
foo[background__style=red]
NB. or perhaps (preferred)
foo[style='background:red']
NB. or perhaps (preferred)
foo[style='background';'red']

NB. use + to actually mean that the "end" of the previous element is joined to the "start" of the next element

NB. use a matrix solver to implement the constraint solving part in the cassowary constraint solving algo

NB. use logic programming to define the required visual constraints and the common styles used for html/css
NB. for example, forall x. x { color ~: background-color }, p[font-size] >= 10px, etc.

NB. a>b in domexpr means that the b is wholly contained by a (required strength), 
NB. thereby banning overflows by default (child forces parent expansion, if possible; otherwise scrolling enabled), ie.
a>b 
	==> a is a parent of b and a contains b 
	==> a is a parent of b and (implied constraints: b.left >= a.left and b.right <= a.right and b.top >= a.top and b.bottom <= a.bottom)

NB. if a box contains an element that doesn't fit wholly in it, the container expands until the contained element fits

NB. an element is placed in the top left of the containing element, with no container elements being placed on the "top left" of the screen
NB. where top left means the default ltr or rtl language defined, with the predefined padding included on the element (based on the carol tuttle type system)

NB. which is better: (JS -> HTML -> HTML) or (JS -> JSON -> HTML) or (HTML_old -> HTML_section -> HTML_new), the second being preferred by hotwire and htmx
NB. it seems the first and second are the most general, though they require js to work

NB. use what jen simmons calls "intrinsic web design" as the default for the auto layout placement algorithm

NB. show grids when debug mode is on when using the constraint css

NB. when compiling my web lang, should it be just the J interpreter, or just my compiler, or perhaps the J interpreter interprets the code, then my compiler compiles the rest?

NB. is quixotism a good name for web-dsl? quote from wikipedia: "It also serves to describe an idealism without regard to practicality. An impulsive person or act might be regarded as quixotic.
NB. Quixotism is usually related to "over-idealism", meaning an idealism that doesn't take consequence or absurdity into account. It is also related to na√Øve romanticism and to utopianism."
NB. nevermind, seems lots of people on github already have that name

NB. take a look at Phoenix Framework

NB. k (or was it q) has implicit joins? how would that be written

NB. the circle with star in it could be used for monadic bind composition, see https://www.youtube.com/watch?v=Ssx2_JKpB3U @ 21:00

NB. what would the meaning of (a+b)>c mean? perhaps (a>c)+b>c or error?

NB. give error when an id is used twice, or append some sort of iteration id?

NB. have a way of defining videos, pictures, and audio (ie. multimedia) using frp and some custom functions (see haskell libs for ideas)

NB. quixotic or quixotical seems to be a good project name

NB. semantic-placement duality: every htmlexpr should have an interpretation in semantic meaning (html) as well as logical constraints (css)
NB. for example div>p{hello}+p{world} could mean that div is a parent of the two ps (html) as well as div contains the two ps (css)

NB. hooks should be function composition instead (use fork with identity if you want a hook)

NB. my lang should support all of the combinators (see code_report's table about combinators and bqn)

NB. use generators to implement streams (as well as actors) in the reactive ui? (generators also used for lazy evaluation)

NB. yellow text with blue background should not be allowed since it doesn't satisfy the constraint that the background color is sufficiently different to the background color
p@cyellow@bblue{Hello world}



NOTE: do not forget to fill out the NuVoc table above

DomDSL {
    Assignment = ((Variable "=")? (Expr | ParenExpr))?
    
    Variable = URL | Identifier
    URL = "/" ("a".."z" | "A" .. "Z" | "/")*
    Expr = (Element Id? Class* Attribute? Style* Body?) (Op (Expr | ParenExpr))?
    ParenExpr = "(" Expr ")" (Op (Expr | ParenExpr))?
    
    Op = ">" | "+" | "^" | "*"
    Body = "{" Text "}"
    Attribute = "[" (Attr "=" Value)+ "]"
    
    Attr = Identifier
    Value = (QuotedText | URL | absoluteURL)
    absoluteURL = ("https://" | "http://")? "www."? ("a".."z" | "A".."z" | "." | "/" | "-" | "0".."9")*
    Domain =  ("a".."z" | "A" .. "Z" | "0" .. "9" | ".")*
    QuotedText = "\"" Text "\""
    
    Style = "@" Text
    
    DomElem = Element Id? Class*
    Element = Identifier
    Class = "." Identifier
    Id = "#" Identifier
    
    Identifier = ("a".."z") ("a".."z" | "A" .. "Z")*
    Text =  ("a".."z" | "A" .. "Z" | "0" .. "9")*
}
NB. tests
p
p#
p#val
p#foo.bar.baz
myVar = p#fooBar
div>p
div>p+p
p{foo} + p{bar}
/foo/bar/baz = div>p
/bar = p{This is bar}
/foo = a[href=/bar]{Click to go to bar}
p@cyellow@bblue{Hello world}
(div>p+(div>p)
div@g2x2
p[title="Hello world"]
img[src=google.com alt="an image"]
